/* automatically generated by rust-bindgen 0.60.1 */

pub const TypeVisibility_LOCAL: TypeVisibility = 0;
pub const TypeVisibility_GLOBAL: TypeVisibility = 1;
pub type TypeVisibility = ::std::os::raw::c_uint;
pub const TypeSpecifier_BYTE: TypeSpecifier = 0;
pub const TypeSpecifier_WORD: TypeSpecifier = 1;
pub const TypeSpecifier_VOID: TypeSpecifier = 2;
pub type TypeSpecifier = ::std::os::raw::c_uint;
pub const TypeQualifier_COPY: TypeQualifier = 0;
pub const TypeQualifier_PTR: TypeQualifier = 1;
pub const TypeQualifier_VAL: TypeQualifier = 2;
pub type TypeQualifier = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompleteType {
    pub type_specifier: TypeSpecifier,
    pub type_qualifier: TypeQualifier,
}
#[test]
fn bindgen_test_layout_CompleteType() {
    assert_eq!(
        ::std::mem::size_of::<CompleteType>(),
        8usize,
        concat!("Size of: ", stringify!(CompleteType))
    );
    assert_eq!(
        ::std::mem::align_of::<CompleteType>(),
        4usize,
        concat!("Alignment of ", stringify!(CompleteType))
    );
    fn test_field_type_specifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CompleteType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_specifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CompleteType),
                "::",
                stringify!(type_specifier)
            )
        );
    }
    test_field_type_specifier();
    fn test_field_type_qualifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CompleteType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_qualifier) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CompleteType),
                "::",
                stringify!(type_qualifier)
            )
        );
    }
    test_field_type_qualifier();
}
pub const UnaryOp_PLUS_PLUS: UnaryOp = 0;
pub const UnaryOp_MINUS_MINUS: UnaryOp = 1;
pub const UnaryOp_ADDROF: UnaryOp = 2;
pub const UnaryOp_DEREF: UnaryOp = 3;
pub const UnaryOp_POSITIVE: UnaryOp = 4;
pub const UnaryOp_NEGATIVE: UnaryOp = 5;
pub type UnaryOp = u8;
pub const BinaryOp_INDEX: BinaryOp = 0;
pub const BinaryOp_FCALL: BinaryOp = 1;
pub const BinaryOp_EQUALS: BinaryOp = 2;
pub const BinaryOp_PLUS: BinaryOp = 3;
pub const BinaryOp_MINUS: BinaryOp = 4;
pub const BinaryOp_PLUS_EQUALS: BinaryOp = 5;
pub const BinaryOp_MINUS_EQUALS: BinaryOp = 6;
pub const BinaryOp_LEFT_SHIFT: BinaryOp = 7;
pub const BinaryOp_RIGHT_SHIFT: BinaryOp = 8;
pub const BinaryOp_BIT_XOR: BinaryOp = 9;
pub const BinaryOp_BIT_AND: BinaryOp = 10;
pub const BinaryOp_BIT_OR: BinaryOp = 11;
pub const BinaryOp_LOG_AND: BinaryOp = 12;
pub const BinaryOp_LOG_OR: BinaryOp = 13;
pub const BinaryOp_EQUALS_EQUALS: BinaryOp = 14;
pub const BinaryOp_NOT_EQUALS: BinaryOp = 15;
pub const BinaryOp_LESS: BinaryOp = 16;
pub const BinaryOp_GREATER: BinaryOp = 17;
pub const BinaryOp_LESS_EQUALS: BinaryOp = 18;
pub const BinaryOp_GREATER_EQUALS: BinaryOp = 19;
pub type BinaryOp = ::std::os::raw::c_uint;
pub const ExpressionType_NUMCONST: ExpressionType = 0;
pub const ExpressionType_STRINGCONST: ExpressionType = 1;
pub const ExpressionType_IDENTIFIER: ExpressionType = 2;
pub const ExpressionType_TERNARYOP: ExpressionType = 3;
pub const ExpressionType_BINARYOP: ExpressionType = 4;
pub const ExpressionType_UNARYOP: ExpressionType = 5;
pub type ExpressionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExpressionValue {
    pub numconst_expression: *mut NumconstExpression_t,
    pub stringconst_expression: *mut StringconstExpression_t,
    pub identifier_expression: *mut IdentifierExpression_t,
    pub ternary_expression: *mut TernaryExpression_t,
    pub binary_expression: *mut BinaryExpression_t,
    pub unary_expression: *mut UnaryExpression_t,
}
#[test]
fn bindgen_test_layout_ExpressionValue() {
    assert_eq!(
        ::std::mem::size_of::<ExpressionValue>(),
        8usize,
        concat!("Size of: ", stringify!(ExpressionValue))
    );
    assert_eq!(
        ::std::mem::align_of::<ExpressionValue>(),
        8usize,
        concat!("Alignment of ", stringify!(ExpressionValue))
    );
    fn test_field_numconst_expression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ExpressionValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numconst_expression) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExpressionValue),
                "::",
                stringify!(numconst_expression)
            )
        );
    }
    test_field_numconst_expression();
    fn test_field_stringconst_expression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ExpressionValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stringconst_expression) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExpressionValue),
                "::",
                stringify!(stringconst_expression)
            )
        );
    }
    test_field_stringconst_expression();
    fn test_field_identifier_expression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ExpressionValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier_expression) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExpressionValue),
                "::",
                stringify!(identifier_expression)
            )
        );
    }
    test_field_identifier_expression();
    fn test_field_ternary_expression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ExpressionValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ternary_expression) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExpressionValue),
                "::",
                stringify!(ternary_expression)
            )
        );
    }
    test_field_ternary_expression();
    fn test_field_binary_expression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ExpressionValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binary_expression) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExpressionValue),
                "::",
                stringify!(binary_expression)
            )
        );
    }
    test_field_binary_expression();
    fn test_field_unary_expression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ExpressionValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unary_expression) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExpressionValue),
                "::",
                stringify!(unary_expression)
            )
        );
    }
    test_field_unary_expression();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Expression {
    pub expression_type: ExpressionType,
    pub expression_value: ExpressionValue,
}
#[test]
fn bindgen_test_layout_Expression() {
    assert_eq!(
        ::std::mem::size_of::<Expression>(),
        16usize,
        concat!("Size of: ", stringify!(Expression))
    );
    assert_eq!(
        ::std::mem::align_of::<Expression>(),
        8usize,
        concat!("Alignment of ", stringify!(Expression))
    );
    fn test_field_expression_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Expression>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).expression_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Expression),
                "::",
                stringify!(expression_type)
            )
        );
    }
    test_field_expression_type();
    fn test_field_expression_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Expression>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).expression_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Expression),
                "::",
                stringify!(expression_value)
            )
        );
    }
    test_field_expression_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumconstExpression_t {
    pub value: u16,
}
#[test]
fn bindgen_test_layout_NumconstExpression_t() {
    assert_eq!(
        ::std::mem::size_of::<NumconstExpression_t>(),
        2usize,
        concat!("Size of: ", stringify!(NumconstExpression_t))
    );
    assert_eq!(
        ::std::mem::align_of::<NumconstExpression_t>(),
        2usize,
        concat!("Alignment of ", stringify!(NumconstExpression_t))
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NumconstExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NumconstExpression_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
pub type NumconstExpression = NumconstExpression_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringconstExpression_t {
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_StringconstExpression_t() {
    assert_eq!(
        ::std::mem::size_of::<StringconstExpression_t>(),
        8usize,
        concat!("Size of: ", stringify!(StringconstExpression_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StringconstExpression_t>(),
        8usize,
        concat!("Alignment of ", stringify!(StringconstExpression_t))
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StringconstExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StringconstExpression_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
pub type StringconstExpression = StringconstExpression_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IdentifierExpression_t {
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_IdentifierExpression_t() {
    assert_eq!(
        ::std::mem::size_of::<IdentifierExpression_t>(),
        8usize,
        concat!("Size of: ", stringify!(IdentifierExpression_t))
    );
    assert_eq!(
        ::std::mem::align_of::<IdentifierExpression_t>(),
        8usize,
        concat!("Alignment of ", stringify!(IdentifierExpression_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<IdentifierExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(IdentifierExpression_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
pub type IdentifierExpression = IdentifierExpression_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TernaryExpression_t {
    pub left: *mut Expression,
    pub center: *mut Expression,
    pub right: *mut Expression,
}
#[test]
fn bindgen_test_layout_TernaryExpression_t() {
    assert_eq!(
        ::std::mem::size_of::<TernaryExpression_t>(),
        24usize,
        concat!("Size of: ", stringify!(TernaryExpression_t))
    );
    assert_eq!(
        ::std::mem::align_of::<TernaryExpression_t>(),
        8usize,
        concat!("Alignment of ", stringify!(TernaryExpression_t))
    );
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<TernaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(TernaryExpression_t),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_center() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<TernaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).center) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(TernaryExpression_t),
                "::",
                stringify!(center)
            )
        );
    }
    test_field_center();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<TernaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(TernaryExpression_t),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
}
pub type TernaryExpression = TernaryExpression_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BinaryExpression_t {
    pub op: BinaryOp,
    pub left: *mut Expression,
    pub right: *mut Expression,
}
#[test]
fn bindgen_test_layout_BinaryExpression_t() {
    assert_eq!(
        ::std::mem::size_of::<BinaryExpression_t>(),
        24usize,
        concat!("Size of: ", stringify!(BinaryExpression_t))
    );
    assert_eq!(
        ::std::mem::align_of::<BinaryExpression_t>(),
        8usize,
        concat!("Alignment of ", stringify!(BinaryExpression_t))
    );
    fn test_field_op() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BinaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(BinaryExpression_t),
                "::",
                stringify!(op)
            )
        );
    }
    test_field_op();
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BinaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(BinaryExpression_t),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BinaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(BinaryExpression_t),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
}
pub type BinaryExpression = BinaryExpression_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnaryExpression_t {
    pub op: UnaryOp,
    pub left: *mut Expression,
}
#[test]
fn bindgen_test_layout_UnaryExpression_t() {
    assert_eq!(
        ::std::mem::size_of::<UnaryExpression_t>(),
        16usize,
        concat!("Size of: ", stringify!(UnaryExpression_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UnaryExpression_t>(),
        8usize,
        concat!("Alignment of ", stringify!(UnaryExpression_t))
    );
    fn test_field_op() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<UnaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(UnaryExpression_t),
                "::",
                stringify!(op)
            )
        );
    }
    test_field_op();
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<UnaryExpression_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(UnaryExpression_t),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
}
pub type UnaryExpression = UnaryExpression_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Variable {
    pub visbility: TypeVisibility,
    pub complete_type: CompleteType,
    pub name: *const ::std::os::raw::c_char,
    pub value: *mut Expression,
}
#[test]
fn bindgen_test_layout_Variable() {
    assert_eq!(
        ::std::mem::size_of::<Variable>(),
        32usize,
        concat!("Size of: ", stringify!(Variable))
    );
    assert_eq!(
        ::std::mem::align_of::<Variable>(),
        8usize,
        concat!("Alignment of ", stringify!(Variable))
    );
    fn test_field_visbility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Variable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visbility) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Variable),
                "::",
                stringify!(visbility)
            )
        );
    }
    test_field_visbility();
    fn test_field_complete_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Variable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).complete_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Variable),
                "::",
                stringify!(complete_type)
            )
        );
    }
    test_field_complete_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Variable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Variable),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Variable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Variable),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableStatement {
    pub num_variables: u8,
    pub variables: *mut Variable,
}
#[test]
fn bindgen_test_layout_VariableStatement() {
    assert_eq!(
        ::std::mem::size_of::<VariableStatement>(),
        16usize,
        concat!("Size of: ", stringify!(VariableStatement))
    );
    assert_eq!(
        ::std::mem::align_of::<VariableStatement>(),
        8usize,
        concat!("Alignment of ", stringify!(VariableStatement))
    );
    fn test_field_num_variables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VariableStatement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_variables) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VariableStatement),
                "::",
                stringify!(num_variables)
            )
        );
    }
    test_field_num_variables();
    fn test_field_variables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VariableStatement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variables) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VariableStatement),
                "::",
                stringify!(variables)
            )
        );
    }
    test_field_variables();
}
pub const StatementType_BLOCK: StatementType = 0;
pub const StatementType_IF: StatementType = 1;
pub const StatementType_WHILE: StatementType = 2;
pub const StatementType_RETURN: StatementType = 3;
pub const StatementType_NIL: StatementType = 4;
pub const StatementType_VARIABLE: StatementType = 5;
pub type StatementType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union StatementValue {
    pub block_statement: *mut BlockStatement_t,
    pub if_statement: *mut IfStatement_t,
    pub while_statement: *mut WhileStatment_t,
    pub return_statement: *mut ReturnStatement_t,
    pub nil_statement: *mut NilStatement_t,
    pub variable_statement: *mut VariableStatement,
}
#[test]
fn bindgen_test_layout_StatementValue() {
    assert_eq!(
        ::std::mem::size_of::<StatementValue>(),
        8usize,
        concat!("Size of: ", stringify!(StatementValue))
    );
    assert_eq!(
        ::std::mem::align_of::<StatementValue>(),
        8usize,
        concat!("Alignment of ", stringify!(StatementValue))
    );
    fn test_field_block_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StatementValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_statement) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StatementValue),
                "::",
                stringify!(block_statement)
            )
        );
    }
    test_field_block_statement();
    fn test_field_if_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StatementValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_statement) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StatementValue),
                "::",
                stringify!(if_statement)
            )
        );
    }
    test_field_if_statement();
    fn test_field_while_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StatementValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).while_statement) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StatementValue),
                "::",
                stringify!(while_statement)
            )
        );
    }
    test_field_while_statement();
    fn test_field_return_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StatementValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).return_statement) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StatementValue),
                "::",
                stringify!(return_statement)
            )
        );
    }
    test_field_return_statement();
    fn test_field_nil_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StatementValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nil_statement) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StatementValue),
                "::",
                stringify!(nil_statement)
            )
        );
    }
    test_field_nil_statement();
    fn test_field_variable_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<StatementValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variable_statement) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StatementValue),
                "::",
                stringify!(variable_statement)
            )
        );
    }
    test_field_variable_statement();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Statement {
    pub statement_type: StatementType,
    pub statement_value: StatementValue,
}
#[test]
fn bindgen_test_layout_Statement() {
    assert_eq!(
        ::std::mem::size_of::<Statement>(),
        16usize,
        concat!("Size of: ", stringify!(Statement))
    );
    assert_eq!(
        ::std::mem::align_of::<Statement>(),
        8usize,
        concat!("Alignment of ", stringify!(Statement))
    );
    fn test_field_statement_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Statement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statement_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Statement),
                "::",
                stringify!(statement_type)
            )
        );
    }
    test_field_statement_type();
    fn test_field_statement_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Statement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statement_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Statement),
                "::",
                stringify!(statement_value)
            )
        );
    }
    test_field_statement_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockStatement_t {
    pub num_statements: u8,
    pub statements: *mut Statement,
}
#[test]
fn bindgen_test_layout_BlockStatement_t() {
    assert_eq!(
        ::std::mem::size_of::<BlockStatement_t>(),
        16usize,
        concat!("Size of: ", stringify!(BlockStatement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<BlockStatement_t>(),
        8usize,
        concat!("Alignment of ", stringify!(BlockStatement_t))
    );
    fn test_field_num_statements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BlockStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_statements) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(BlockStatement_t),
                "::",
                stringify!(num_statements)
            )
        );
    }
    test_field_num_statements();
    fn test_field_statements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BlockStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statements) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(BlockStatement_t),
                "::",
                stringify!(statements)
            )
        );
    }
    test_field_statements();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IfStatement_t {
    pub condition: *mut Expression,
    pub statement: *mut Statement,
}
#[test]
fn bindgen_test_layout_IfStatement_t() {
    assert_eq!(
        ::std::mem::size_of::<IfStatement_t>(),
        16usize,
        concat!("Size of: ", stringify!(IfStatement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<IfStatement_t>(),
        8usize,
        concat!("Alignment of ", stringify!(IfStatement_t))
    );
    fn test_field_condition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<IfStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).condition) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(IfStatement_t),
                "::",
                stringify!(condition)
            )
        );
    }
    test_field_condition();
    fn test_field_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<IfStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statement) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(IfStatement_t),
                "::",
                stringify!(statement)
            )
        );
    }
    test_field_statement();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WhileStatement_t {
    pub condition: *mut Expression,
    pub statement: *mut Statement,
}
#[test]
fn bindgen_test_layout_WhileStatement_t() {
    assert_eq!(
        ::std::mem::size_of::<WhileStatement_t>(),
        16usize,
        concat!("Size of: ", stringify!(WhileStatement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<WhileStatement_t>(),
        8usize,
        concat!("Alignment of ", stringify!(WhileStatement_t))
    );
    fn test_field_condition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<WhileStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).condition) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(WhileStatement_t),
                "::",
                stringify!(condition)
            )
        );
    }
    test_field_condition();
    fn test_field_statement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<WhileStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statement) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(WhileStatement_t),
                "::",
                stringify!(statement)
            )
        );
    }
    test_field_statement();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnStatement_t {
    pub value: *mut Expression,
}
#[test]
fn bindgen_test_layout_ReturnStatement_t() {
    assert_eq!(
        ::std::mem::size_of::<ReturnStatement_t>(),
        8usize,
        concat!("Size of: ", stringify!(ReturnStatement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ReturnStatement_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ReturnStatement_t))
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ReturnStatement_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ReturnStatement_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NilStatement_t {}
#[test]
fn bindgen_test_layout_NilStatement_t() {
    assert_eq!(
        ::std::mem::size_of::<NilStatement_t>(),
        0usize,
        concat!("Size of: ", stringify!(NilStatement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<NilStatement_t>(),
        1usize,
        concat!("Alignment of ", stringify!(NilStatement_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Argument {
    pub name: *const ::std::os::raw::c_char,
    pub complete_type: CompleteType,
}
#[test]
fn bindgen_test_layout_Argument() {
    assert_eq!(
        ::std::mem::size_of::<Argument>(),
        16usize,
        concat!("Size of: ", stringify!(Argument))
    );
    assert_eq!(
        ::std::mem::align_of::<Argument>(),
        8usize,
        concat!("Alignment of ", stringify!(Argument))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Argument>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Argument),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_complete_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Argument>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).complete_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Argument),
                "::",
                stringify!(complete_type)
            )
        );
    }
    test_field_complete_type();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Arguments {
    pub num_arguments: u8,
    pub arguments: *mut Argument,
}
#[test]
fn bindgen_test_layout_Arguments() {
    assert_eq!(
        ::std::mem::size_of::<Arguments>(),
        16usize,
        concat!("Size of: ", stringify!(Arguments))
    );
    assert_eq!(
        ::std::mem::align_of::<Arguments>(),
        8usize,
        concat!("Alignment of ", stringify!(Arguments))
    );
    fn test_field_num_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Arguments>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_arguments) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Arguments),
                "::",
                stringify!(num_arguments)
            )
        );
    }
    test_field_num_arguments();
    fn test_field_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Arguments>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Arguments),
                "::",
                stringify!(arguments)
            )
        );
    }
    test_field_arguments();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Function {
    pub name: *const ::std::os::raw::c_char,
    pub return_type: CompleteType,
    pub arguments: Arguments,
    pub body: *mut Statement,
}
#[test]
fn bindgen_test_layout_Function() {
    assert_eq!(
        ::std::mem::size_of::<Function>(),
        40usize,
        concat!("Size of: ", stringify!(Function))
    );
    assert_eq!(
        ::std::mem::align_of::<Function>(),
        8usize,
        concat!("Alignment of ", stringify!(Function))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Function>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Function),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_return_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Function>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).return_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Function),
                "::",
                stringify!(return_type)
            )
        );
    }
    test_field_return_type();
    fn test_field_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Function>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Function),
                "::",
                stringify!(arguments)
            )
        );
    }
    test_field_arguments();
    fn test_field_body() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Function>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Function),
                "::",
                stringify!(body)
            )
        );
    }
    test_field_body();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Program {
    pub num_functions: u8,
    pub functions: *mut Function,
}
#[test]
fn bindgen_test_layout_Program() {
    assert_eq!(
        ::std::mem::size_of::<Program>(),
        16usize,
        concat!("Size of: ", stringify!(Program))
    );
    assert_eq!(
        ::std::mem::align_of::<Program>(),
        8usize,
        concat!("Alignment of ", stringify!(Program))
    );
    fn test_field_num_functions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Program>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_functions) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Program),
                "::",
                stringify!(num_functions)
            )
        );
    }
    test_field_num_functions();
    fn test_field_functions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<Program>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).functions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Program),
                "::",
                stringify!(functions)
            )
        );
    }
    test_field_functions();
}
extern "C" {
    pub fn generate(program: *const Program);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WhileStatment_t {
    pub _address: u8,
}
