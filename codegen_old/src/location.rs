/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _LIBCPP_VERSION: u32 = 13000;
pub const _LIBCPP_ABI_VERSION: u32 = 1;
pub const _LIBCPP_STD_VER: u32 = 11;
pub const _LIBCPP_OBJECT_FORMAT_MACHO: u32 = 1;
pub const _LIBCPP_HIDE_FROM_ABI_PER_TU: u32 = 1;
pub const _LIBCPP_DEBUG_LEVEL: u32 = 0;
pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const TIME_UTC: u32 = 1;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_CURRENT: u32 = 5;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION: u32 = 3;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MESSAGES: u32 = 6;
pub const _LC_LAST: u32 = 7;
pub const LC_COLLATE_MASK: u32 = 1;
pub const LC_CTYPE_MASK: u32 = 2;
pub const LC_MESSAGES_MASK: u32 = 4;
pub const LC_MONETARY_MASK: u32 = 8;
pub const LC_NUMERIC_MASK: u32 = 16;
pub const LC_TIME_MASK: u32 = 32;
pub const _LC_NUM_MASK: u32 = 6;
pub const _LC_LAST_MASK: u32 = 32;
pub const _LIBCPP_HAS_CATOPEN: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const NL_SETD: u32 = 1;
pub const NL_CAT_LOCALE: u32 = 1;
pub const _LIBCPP_GET_C_LOCALE: u32 = 0;
pub const YY_NULLPTR: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nullptr_t {
    pub __lx: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nullptr_t___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_std_nullptr_t___nat() {
    assert_eq!(
        ::std::mem::size_of::<std_nullptr_t___nat>(),
        4usize,
        concat!("Size of: ", stringify!(std_nullptr_t___nat))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nullptr_t___nat>(),
        4usize,
        concat!("Alignment of ", stringify!(std_nullptr_t___nat))
    );
    fn test_field___for_bool_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_nullptr_t___nat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__for_bool_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_nullptr_t___nat),
                "::",
                stringify!(__for_bool_)
            )
        );
    }
    test_field___for_bool_();
}
#[test]
fn bindgen_test_layout_std_nullptr_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nullptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(std_nullptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nullptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(std_nullptr_t))
    );
    fn test_field___lx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_nullptr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_nullptr_t),
                "::",
                stringify!(__lx)
            )
        );
    }
    test_field___lx();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios;
pub type std_wios = std_basic_ios;
pub type std_streambuf = std_basic_streambuf<::std::os::raw::c_char>;
pub type std_istream = std_basic_istream;
pub type std_ostream = std_basic_ostream;
pub type std_iostream = std_basic_iostream;
pub type std_stringbuf = std_basic_stringbuf;
pub type std_istringstream = std_basic_istringstream;
pub type std_ostringstream = std_basic_ostringstream;
pub type std_stringstream = std_basic_stringstream;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wstreambuf = std_basic_streambuf<u32>;
pub type std_wistream = std_basic_istream;
pub type std_wostream = std_basic_ostream;
pub type std_wiostream = std_basic_iostream;
pub type std_wstringbuf = std_basic_stringbuf;
pub type std_wistringstream = std_basic_istringstream;
pub type std_wostringstream = std_basic_ostringstream;
pub type std_wstringstream = std_basic_stringstream;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
pub type std_streampos = std_fpos<mbstate_t>;
pub type std_wstreampos = std_fpos<mbstate_t>;
pub type std_u16streampos = std_fpos<mbstate_t>;
pub type std_u32streampos = std_fpos<mbstate_t>;
pub type std_streamoff = ::std::os::raw::c_longlong;
pub type std_string = std_basic_string;
pub type std_wstring = std_basic_string;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
#[repr(C)]
pub struct std___save_flags<_CharT> {
    pub __stream_: *mut std___save_flags___stream_type,
    pub __fmtflags_: std___save_flags_fmtflags,
    pub __fill_: _CharT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std___save_flags___stream_type = std_basic_ios;
pub type std___save_flags_fmtflags = std___save_flags___stream_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_integral {
    pub _address: u8,
}
pub const std___libcpp_is_integral_value: std___libcpp_is_integral__bindgen_ty_1 = 0;
pub type std___libcpp_is_integral__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_debug_info {
    pub __file_: *const ::std::os::raw::c_char,
    pub __line_: ::std::os::raw::c_int,
    pub __pred_: *const ::std::os::raw::c_char,
    pub __msg_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std___libcpp_debug_info() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_debug_info>(),
        32usize,
        concat!("Size of: ", stringify!(std___libcpp_debug_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_debug_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std___libcpp_debug_info))
    );
    fn test_field___file_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___libcpp_debug_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__file_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___libcpp_debug_info),
                "::",
                stringify!(__file_)
            )
        );
    }
    test_field___file_();
    fn test_field___line_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___libcpp_debug_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__line_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std___libcpp_debug_info),
                "::",
                stringify!(__line_)
            )
        );
    }
    test_field___line_();
    fn test_field___pred_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___libcpp_debug_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pred_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(std___libcpp_debug_info),
                "::",
                stringify!(__pred_)
            )
        );
    }
    test_field___pred_();
    fn test_field___msg_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___libcpp_debug_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__msg_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(std___libcpp_debug_info),
                "::",
                stringify!(__msg_)
            )
        );
    }
    test_field___msg_();
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__119__libcpp_debug_info4whatEv"]
    pub fn std___libcpp_debug_info_what(this: *const std___libcpp_debug_info) -> std_string;
}
impl std___libcpp_debug_info {
    #[inline]
    pub unsafe fn what(&self) -> std_string {
        std___libcpp_debug_info_what(self)
    }
}
pub type std___libcpp_debug_function_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const std___libcpp_debug_info)>;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__libcpp_debug_functionE"]
    pub static mut std___libcpp_debug_function: std___libcpp_debug_function_type;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__129__libcpp_abort_debug_functionERKNS_19__libcpp_debug_infoE"]
    pub fn std___libcpp_abort_debug_function(arg1: *const std___libcpp_debug_info);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__127__libcpp_set_debug_functionEPFvRKNS_19__libcpp_debug_infoEE"]
    pub fn std___libcpp_set_debug_function(__func: std___libcpp_debug_function_type) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std_value: _Tp;
}
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std__BoolConstant = u8;
pub type std__EnableIf = u8;
pub type std__If = u8;
pub type std__Or = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Not {
    pub _address: u8,
}
pub type std__FirstType = u8;
pub type std__SecondType = u8;
pub type std___expand_to_true = std_true_type;
pub type std__And<_Pred> = _Pred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Lazy {
    pub _address: u8,
}
pub type std__IsValidExpansion = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___void_t {
    pub _address: u8,
}
pub type std___void_t_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___identity {
    pub _address: u8,
}
pub type std___identity_type<_Tp> = _Tp;
pub type std___identity_t = std___identity;
pub type std_conditional_type<_If> = _If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
pub type std__IsSame = std__BoolConstant;
pub type std__IsNotSame = std__BoolConstant;
pub type std___test_for_primary_template = std__EnableIf;
pub type std___is_primary_template = std__IsValidExpansion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___two {
    pub __lx: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_std___two() {
    assert_eq!(
        ::std::mem::size_of::<std___two>(),
        2usize,
        concat!("Size of: ", stringify!(std___two))
    );
    assert_eq!(
        ::std::mem::align_of::<std___two>(),
        1usize,
        concat!("Alignment of ", stringify!(std___two))
    );
    fn test_field___lx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___two>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___two),
                "::",
                stringify!(__lx)
            )
        );
    }
    test_field___lx();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type = std_remove_volatile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t_impl {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_nullptr_t_impl_open0_std_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_nullptr_t_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_nullptr_t_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_nullptr_t_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_nullptr_t_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _base: std___is_nullptr_t_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_signed_integer {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_unsigned_integer {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_char_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_short_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_int_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_long_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_long_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_floating_point {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _base: std___libcpp_is_floating_point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_member_pointer {
    pub _address: u8,
}
pub const std___libcpp_is_member_pointer___is_member: std___libcpp_is_member_pointer__bindgen_ty_1 =
    0;
pub const std___libcpp_is_member_pointer___is_func: std___libcpp_is_member_pointer__bindgen_ty_1 =
    0;
pub const std___libcpp_is_member_pointer___is_obj: std___libcpp_is_member_pointer__bindgen_ty_1 = 0;
pub type std___libcpp_is_member_pointer__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_block {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_is_scalar_open0_std_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_scalar>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_scalar)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_scalar>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_scalar)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___is_referenceable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___is_referenceable_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___is_referenceable_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_referenceable_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___is_referenceable_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
pub type std___add_lvalue_reference_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = u8;
pub type std___add_rvalue_reference_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uncvref {
    pub _address: u8,
}
pub type std___uncvref_type = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unconstref {
    pub _address: u8,
}
pub type std___unconstref_type = std_remove_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_same_uncvref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___any {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___any() {
    assert_eq!(
        ::std::mem::size_of::<std___any>(),
        1usize,
        concat!("Size of: ", stringify!(std___any))
    );
    assert_eq!(
        ::std::mem::align_of::<std___any>(),
        1usize,
        concat!("Alignment of ", stringify!(std___any))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15__anyC1Ez"]
    pub fn std___any___any(this: *mut std___any, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_type<_Tp> = _Tp;
pub type std___add_pointer_impl_type = *mut std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_add_pointer_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std___decay_type = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay__Up = std_remove_reference;
pub type std_decay_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_core_convertible {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_list {
    pub _address: u8,
}
pub type std___type_list__Head<_Hp> = _Hp;
pub type std___type_list__Tail<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nat {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nat() {
    assert_eq!(
        ::std::mem::size_of::<std___nat>(),
        1usize,
        concat!("Size of: ", stringify!(std___nat))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nat>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nat))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___align_type {
    pub _address: u8,
}
pub type std___align_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___struct_double {
    pub __lx: f64,
}
#[test]
fn bindgen_test_layout_std___struct_double() {
    assert_eq!(
        ::std::mem::size_of::<std___struct_double>(),
        8usize,
        concat!("Size of: ", stringify!(std___struct_double))
    );
    assert_eq!(
        ::std::mem::align_of::<std___struct_double>(),
        8usize,
        concat!("Alignment of ", stringify!(std___struct_double))
    );
    fn test_field___lx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___struct_double>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___struct_double),
                "::",
                stringify!(__lx)
            )
        );
    }
    test_field___lx();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___struct_double4 {
    pub __lx: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_std___struct_double4() {
    assert_eq!(
        ::std::mem::size_of::<std___struct_double4>(),
        32usize,
        concat!("Size of: ", stringify!(std___struct_double4))
    );
    assert_eq!(
        ::std::mem::align_of::<std___struct_double4>(),
        8usize,
        concat!("Alignment of ", stringify!(std___struct_double4))
    );
    fn test_field___lx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___struct_double4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___struct_double4),
                "::",
                stringify!(__lx)
            )
        );
    }
    test_field___lx();
}
pub type std___all_types = std___type_list;
extern "C" {
    #[link_name = "\u{1}__min"]
    pub static std___select_align___min: size_t;
}
extern "C" {
    #[link_name = "\u{1}__max"]
    pub static std___select_align___max: size_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___select_align_value: size_t;
}
pub type std_aligned_storage__Aligner = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __align: std_aligned_storage__Aligner,
    pub __data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
pub type std_aligned_union_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_type {
    pub _address: u8,
}
pub type std___numeric_type_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___numeric_type_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___numeric_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___numeric_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___numeric_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___numeric_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___promote {
    pub _address: u8,
}
pub type std___signed_types = std___type_list;
pub type std___unsigned_types = std___type_list;
pub type std___apply_cv_type<_Up> = _Up;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type2_imp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_common_type_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_common_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_common_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_common_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_common_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___select_2nd {
    pub _address: u8,
}
pub type std___select_2nd_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_apply {
    pub _address: u8,
}
pub type std___is_destructible_apply_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructor_wellformed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_is_destructible_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_destructible>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_destructible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_destructible>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_destructible)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_pointer_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_pointer_class_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_nothrow_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_reference_wrapper_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_reference_wrapper {
    pub _base: std___is_reference_wrapper_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
pub type std___swap_result_t = ::std::os::raw::c_void;
pub type std___detail___swappable_with___swap1<_Tp> = _Tp;
pub type std___detail___swappable_with___swap2<_Up> = _Up;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
pub type std___sfinae_underlying_type_type = std_underlying_type;
pub type std___sfinae_underlying_type___promoted_type = std___sfinae_underlying_type_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_fail_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_fail_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_fail_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_fail_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_fail_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_fail_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_self_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_self_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_self_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_self_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_self_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_self_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_first_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_first_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_first_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_first_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_first_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_first_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_extract_key {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_extract_map_key {
    pub _address: u8,
}
pub type std__IsCharLikeType = std__And<_Pred>;
pub type std___make_const_lvalue_ref = *mut std_remove_reference;
pub type std___move_if_noexcept_result_t<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_unary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_unary_function___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
pub type std___derives_from_unary_function_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_binary_function___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
pub type std___derives_from_binary_function_type<_Tp> = _Tp;
pub type std___weak_result_type_imp_result_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___enable_invoke {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__invokeENS_5__anyEz"]
    pub fn std___invoke(arg1: std___any, ...) -> std___nat;
}
pub type std___invoke_return_type = std___weak_result_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_return0 {
    pub _address: u8,
}
pub type std___invoke_return0_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_return1 {
    pub _address: u8,
}
pub type std___invoke_return1_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_return2 {
    pub _address: u8,
}
pub type std___invoke_return2_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
pub type std_plus___result_type<_Tp> = _Tp;
pub type std_plus_result_type<_Tp> = _Tp;
pub type std_plus_first_argument_type<_Tp> = _Tp;
pub type std_plus_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
pub type std_minus___result_type<_Tp> = _Tp;
pub type std_minus_result_type<_Tp> = _Tp;
pub type std_minus_first_argument_type<_Tp> = _Tp;
pub type std_minus_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
pub type std_multiplies___result_type<_Tp> = _Tp;
pub type std_multiplies_result_type<_Tp> = _Tp;
pub type std_multiplies_first_argument_type<_Tp> = _Tp;
pub type std_multiplies_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
pub type std_divides___result_type<_Tp> = _Tp;
pub type std_divides_result_type<_Tp> = _Tp;
pub type std_divides_first_argument_type<_Tp> = _Tp;
pub type std_divides_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
pub type std_modulus___result_type<_Tp> = _Tp;
pub type std_modulus_result_type<_Tp> = _Tp;
pub type std_modulus_first_argument_type<_Tp> = _Tp;
pub type std_modulus_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
pub type std_negate___result_type<_Tp> = _Tp;
pub type std_negate_result_type<_Tp> = _Tp;
pub type std_negate_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
pub type std_bit_and___result_type<_Tp> = _Tp;
pub type std_bit_and_result_type<_Tp> = _Tp;
pub type std_bit_and_first_argument_type<_Tp> = _Tp;
pub type std_bit_and_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
pub type std_bit_or___result_type<_Tp> = _Tp;
pub type std_bit_or_result_type<_Tp> = _Tp;
pub type std_bit_or_first_argument_type<_Tp> = _Tp;
pub type std_bit_or_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
pub type std_bit_xor___result_type<_Tp> = _Tp;
pub type std_bit_xor_result_type<_Tp> = _Tp;
pub type std_bit_xor_first_argument_type<_Tp> = _Tp;
pub type std_bit_xor_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
pub type std_equal_to___result_type = bool;
pub type std_equal_to_result_type = bool;
pub type std_equal_to_first_argument_type<_Tp> = _Tp;
pub type std_equal_to_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
pub type std_not_equal_to___result_type = bool;
pub type std_not_equal_to_result_type = bool;
pub type std_not_equal_to_first_argument_type<_Tp> = _Tp;
pub type std_not_equal_to_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less___result_type = bool;
pub type std_less_result_type = bool;
pub type std_less_first_argument_type<_Tp> = _Tp;
pub type std_less_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
pub type std_less_equal___result_type = bool;
pub type std_less_equal_result_type = bool;
pub type std_less_equal_first_argument_type<_Tp> = _Tp;
pub type std_less_equal_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
pub type std_greater_equal___result_type = bool;
pub type std_greater_equal_result_type = bool;
pub type std_greater_equal_first_argument_type<_Tp> = _Tp;
pub type std_greater_equal_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
pub type std_greater___result_type = bool;
pub type std_greater_result_type = bool;
pub type std_greater_first_argument_type<_Tp> = _Tp;
pub type std_greater_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
pub type std_logical_and___result_type = bool;
pub type std_logical_and_result_type = bool;
pub type std_logical_and_first_argument_type<_Tp> = _Tp;
pub type std_logical_and_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
pub type std_logical_not___result_type = bool;
pub type std_logical_not_result_type = bool;
pub type std_logical_not_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
pub type std_logical_or___result_type = bool;
pub type std_logical_or_result_type = bool;
pub type std_logical_or_first_argument_type<_Tp> = _Tp;
pub type std_logical_or_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Tp> {
    pub __f_: *mut std_reference_wrapper_type<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_allocator_arg_t() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_allocator_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_allocator_arg_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__113allocator_argE"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_like {
    pub _base: std_false_type,
}
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
pub type std___libcpp_numeric_limits_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
pub type std_numeric_limits___base = u8;
pub type std_numeric_limits_type = std_numeric_limits___base;
extern "C" {
    #[link_name = "\u{1}is_specialized"]
    pub static std_is_specialized: bool;
}
extern "C" {
    #[link_name = "\u{1}digits"]
    pub static std_digits: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}digits10"]
    pub static std_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_digits10"]
    pub static std_max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}is_signed"]
    pub static std_is_signed: bool;
}
extern "C" {
    #[link_name = "\u{1}is_integer"]
    pub static std_is_integer: bool;
}
extern "C" {
    #[link_name = "\u{1}is_exact"]
    pub static std_is_exact: bool;
}
extern "C" {
    #[link_name = "\u{1}radix"]
    pub static std_radix: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}min_exponent"]
    pub static std_min_exponent: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}min_exponent10"]
    pub static std_min_exponent10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_exponent"]
    pub static std_max_exponent: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_exponent10"]
    pub static std_max_exponent10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}has_infinity"]
    pub static std_has_infinity: bool;
}
extern "C" {
    #[link_name = "\u{1}has_quiet_NaN"]
    pub static std_has_quiet_NaN: bool;
}
extern "C" {
    #[link_name = "\u{1}has_signaling_NaN"]
    pub static std_has_signaling_NaN: bool;
}
extern "C" {
    #[link_name = "\u{1}has_denorm"]
    pub static std_has_denorm: std_float_denorm_style;
}
extern "C" {
    #[link_name = "\u{1}has_denorm_loss"]
    pub static std_has_denorm_loss: bool;
}
extern "C" {
    #[link_name = "\u{1}is_iec559"]
    pub static std_is_iec559: bool;
}
extern "C" {
    #[link_name = "\u{1}is_bounded"]
    pub static std_is_bounded: bool;
}
extern "C" {
    #[link_name = "\u{1}is_modulo"]
    pub static std_is_modulo: bool;
}
extern "C" {
    #[link_name = "\u{1}traps"]
    pub static std_traps: bool;
}
extern "C" {
    #[link_name = "\u{1}tinyness_before"]
    pub static std_tinyness_before: bool;
}
extern "C" {
    #[link_name = "\u{1}round_style"]
    pub static std_round_style: std_float_round_style;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unwrap_reference {
    pub _address: u8,
}
pub type std___unwrap_reference_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unwrap_ref_decay {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(
        ::std::mem::size_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_piecewise_construct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_piecewise_construct_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119piecewise_constructE"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_output_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_output_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_output_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_traits_cache {
    pub _address: u8,
}
pub type std___iter_traits_cache_type = std__If;
pub type std__ITER_TRAITS = std___iter_traits_cache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_concept_test {
    pub _address: u8,
}
pub type std___iter_concept_concept_test__Apply = std__ITER_TRAITS;
#[test]
fn bindgen_test_layout_std___iter_concept_concept_test() {
    assert_eq!(
        ::std::mem::size_of::<std___iter_concept_concept_test>(),
        1usize,
        concat!("Size of: ", stringify!(std___iter_concept_concept_test))
    );
    assert_eq!(
        ::std::mem::align_of::<std___iter_concept_concept_test>(),
        1usize,
        concat!("Alignment of ", stringify!(std___iter_concept_concept_test))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_category_test {
    pub _address: u8,
}
pub type std___iter_concept_category_test__Apply = std__ITER_TRAITS;
#[test]
fn bindgen_test_layout_std___iter_concept_category_test() {
    assert_eq!(
        ::std::mem::size_of::<std___iter_concept_category_test>(),
        1usize,
        concat!("Size of: ", stringify!(std___iter_concept_category_test))
    );
    assert_eq!(
        ::std::mem::align_of::<std___iter_concept_category_test>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___iter_concept_category_test)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_random_fallback {
    pub _address: u8,
}
pub type std___iter_concept_random_fallback__Apply = std__EnableIf;
#[test]
fn bindgen_test_layout_std___iter_concept_random_fallback() {
    assert_eq!(
        ::std::mem::size_of::<std___iter_concept_random_fallback>(),
        1usize,
        concat!("Size of: ", stringify!(std___iter_concept_random_fallback))
    );
    assert_eq!(
        ::std::mem::align_of::<std___iter_concept_random_fallback>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___iter_concept_random_fallback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___test_iter_concept<_Tester> {
    pub _base_1: _Tester,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tester>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_cache {
    pub _address: u8,
}
pub type std___iter_concept_cache_type = std__Or;
pub type std__ITER_CONCEPT = std___iter_concept_cache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_typedefs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_typedefs___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_concept {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_concept___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_input_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_forward_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_bidirectional_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_random_access_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_contiguous_iterator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_exactly_cpp17_input_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_element_type {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_difference_type {
    pub _base: std_false_type,
}
pub type std___pointer_traits_difference_type_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_rebind {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_rebind___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
pub type std___pointer_traits_rebind_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = u8;
pub type std_pointer_traits_difference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits_rebind {
    pub _address: u8,
}
pub type std_pointer_traits_rebind_other = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___nat {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___rebind_pointer {
    pub _address: u8,
}
pub type std___rebind_pointer_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___to_address_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub __i: std___wrap_iter_iterator_type<_Iter>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub __pred_: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_bind_expression {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_bind_expression {
    pub _base: std___is_bind_expression,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_placeholder {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_placeholder {
    pub _base: std___is_placeholder,
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_1E"]
    pub static std_placeholders__1: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_2E"]
    pub static std_placeholders__2: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_3E"]
    pub static std_placeholders__3: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_4E"]
    pub static std_placeholders__4: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_5E"]
    pub static std_placeholders__5: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_6E"]
    pub static std_placeholders__6: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_7E"]
    pub static std_placeholders__7: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_8E"]
    pub static std_placeholders__8: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_9E"]
    pub static std_placeholders__9: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders3_10E"]
    pub static std_placeholders__10: u8;
}
#[repr(C)]
pub struct std_binder1st<__Operation> {
    pub op: __Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<__Operation>>,
}
#[repr(C)]
pub struct std_binder2nd<__Operation> {
    pub op: __Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<__Operation>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_pointer {
    pub _base: std_false_type,
}
pub type std___pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_const_pointer {
    pub _base: std_false_type,
}
pub type std___const_pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_void_pointer {
    pub _base: std_false_type,
}
pub type std___void_pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_const_void_pointer {
    pub _base: std_false_type,
}
pub type std___const_void_pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_size_type {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_alloc_traits_difference_type {
    pub _base: std_false_type,
}
pub type std___alloc_traits_difference_type_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_propagate_on_container_copy_assignment {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_propagate_on_container_move_assignment {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_propagate_on_container_swap {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_is_always_equal {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_rebind_other {
    pub _base: std_false_type,
}
pub type std___allocator_traits_rebind_type<_Tp> = _Tp;
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocate_hint {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_construct_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_construct {
    pub _base: std___has_construct_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_destroy {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_max_size {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_select_on_container_copy_construction {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = [u8; 0usize];
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = [u8; 0usize];
pub type std_allocator_traits_const_void_pointer = [u8; 0usize];
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits_rebind_alloc {
    pub _address: u8,
}
pub type std_allocator_traits_rebind_alloc_other = std___allocator_traits_rebind_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits_rebind_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___rebind_alloc_helper {
    pub _address: u8,
}
pub type std___rebind_alloc_helper_type<_Traits> = _Traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_default_allocator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_move_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_copy_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___default_init_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___default_init_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___default_init_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___default_init_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___default_init_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___default_init_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___value_init_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___value_init_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___value_init_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___value_init_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___value_init_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___value_init_tag))
    );
}
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std___allocation_guard<_Alloc> {
    pub __alloc_: _Alloc,
    pub __n_: std___allocation_guard__Size,
    pub __ptr_: std___allocation_guard__Pointer,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___allocation_guard__Pointer = std_allocator_traits;
pub type std___allocation_guard__Size = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std___libcpp_refstring {
    pub __imp_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std___libcpp_refstring() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_refstring>(),
        8usize,
        concat!("Size of: ", stringify!(std___libcpp_refstring))
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_refstring>(),
        8usize,
        concat!("Alignment of ", stringify!(std___libcpp_refstring))
    );
    fn test_field___imp_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___libcpp_refstring>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__imp_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___libcpp_refstring),
                "::",
                stringify!(__imp_)
            )
        );
    }
    test_field___imp_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121__throw_runtime_errorEPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char);
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_const_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__PairT {
    pub first: size_t,
    pub second: size_t,
}
#[test]
fn bindgen_test_layout_std__PairT() {
    assert_eq!(
        ::std::mem::size_of::<std__PairT>(),
        16usize,
        concat!("Size of: ", stringify!(std__PairT))
    );
    assert_eq!(
        ::std::mem::align_of::<std__PairT>(),
        8usize,
        concat!("Alignment of ", stringify!(std__PairT))
    );
    fn test_field_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std__PairT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std__PairT),
                "::",
                stringify!(first)
            )
        );
    }
    test_field_first();
    fn test_field_second() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std__PairT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).second) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std__PairT),
                "::",
                stringify!(second)
            )
        );
    }
    test_field_second();
}
#[test]
fn __bindgen_test_layout_std_hash_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Tp> {
    pub __ptr_: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Tp> {
    pub __ptr_: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_auto_ptr_element_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_auto_ptr_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unique_ptr_deleter_sfinae {
    pub _address: u8,
}
pub type std___unique_ptr_deleter_sfinae___lval_ref_type<_Deleter> = *const _Deleter;
pub type std___unique_ptr_deleter_sfinae___good_rval_ref_type<_Deleter> = *mut _Deleter;
pub type std___unique_ptr_deleter_sfinae___enable_rval_overload = std_true_type;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub __ptr_: std___compressed_pair,
}
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
pub type std_unique_ptr__DeleterSFINAE = std___unique_ptr_deleter_sfinae;
pub type std_unique_ptr__LValRefType = u8;
pub type std_unique_ptr__GoodRValRefType = u8;
pub type std_unique_ptr__BadRValRefType = u8;
pub type std_unique_ptr__EnableIfDeleterDefaultConstructible = u8;
pub type std_unique_ptr__EnableIfDeleterConstructible = u8;
pub type std_unique_ptr__EnableIfMoveConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterAssignable = u8;
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_gcd_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_lcm_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_abs_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_sign_value: intmax_t;
}
pub const std___ll_mul_nan: intmax_t = -9223372036854775808;
extern "C" {
    #[link_name = "\u{1}min"]
    pub static std___ll_mul_min: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}max"]
    pub static std___ll_mul_max: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__a_x"]
    pub static std___ll_mul___a_x: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__a_y"]
    pub static std___ll_mul___a_y: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___ll_mul_value: intmax_t;
}
pub const std___ll_div_nan: intmax_t = -9223372036854775808;
extern "C" {
    #[link_name = "\u{1}min"]
    pub static std___ll_div_min: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}max"]
    pub static std___ll_div_max: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___ll_div_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__na"]
    pub static std_ratio___na: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__da"]
    pub static std_ratio___da: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__s"]
    pub static std_ratio___s: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__gcd"]
    pub static std_ratio___gcd: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_num: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_den: intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_ratio {
    pub _base: std_false_type,
}
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_multiply {
    pub _address: u8,
}
pub type std___ratio_multiply_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_multiply {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_divide {
    pub _address: u8,
}
pub type std___ratio_divide_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_divide {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_add {
    pub _address: u8,
}
pub type std___ratio_add_type = std_ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_add {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_subtract {
    pub _address: u8,
}
pub type std___ratio_subtract_type = std_ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_subtract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_gcd {
    pub _address: u8,
}
pub type std___ratio_gcd_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_duration {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _base: std_is_floating_point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration<_Rep> {
    pub __rep_: std_chrono_duration_rep<_Rep>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration___no_overflow {
    pub _address: u8,
}
pub type std_chrono_duration___no_overflow_type = u8;
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = [u8; 0usize];
pub type std_chrono_nanoseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_microseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_milliseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_seconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_minutes = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_hours = std_chrono_duration<::std::os::raw::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___duration_eq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___duration_lt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point<_Duration> {
    pub __d_: std_chrono_time_point_duration<_Duration>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Duration>>,
}
pub type std_chrono_time_point_clock<_Clock> = _Clock;
pub type std_chrono_time_point_duration<_Duration> = _Duration;
pub type std_chrono_time_point_rep = [u8; 0usize];
pub type std_chrono_time_point_period = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_system_clock {
    pub _address: u8,
}
pub type std_chrono_system_clock_duration = std_chrono_microseconds;
pub type std_chrono_system_clock_rep = rep;
pub type std_chrono_system_clock_period = u8;
pub type std_chrono_system_clock_time_point =
    std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>;
pub const std_chrono_system_clock_is_steady: bool = false;
#[test]
fn bindgen_test_layout_std_chrono_system_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_system_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono_system_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_system_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono_system_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12system_clock3nowEv"]
    pub fn std_chrono_system_clock_now() -> std_chrono_system_clock_time_point;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12system_clock9to_time_tERKNS0_10time_pointIS1_NS0_8durationIxNS_5ratioILl1ELl1000000EEEEEEE"]
    pub fn std_chrono_system_clock_to_time_t(
        __t: *const std_chrono_system_clock_time_point,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12system_clock11from_time_tEl"]
    pub fn std_chrono_system_clock_from_time_t(__t: time_t) -> std_chrono_system_clock_time_point;
}
impl std_chrono_system_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_now()
    }
    #[inline]
    pub unsafe fn to_time_t(__t: *const std_chrono_system_clock_time_point) -> time_t {
        std_chrono_system_clock_to_time_t(__t)
    }
    #[inline]
    pub unsafe fn from_time_t(__t: time_t) -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_from_time_t(__t)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_steady_clock {
    pub _address: u8,
}
pub type std_chrono_steady_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_steady_clock_rep = rep;
pub type std_chrono_steady_clock_period = u8;
pub type std_chrono_steady_clock_time_point =
    std_chrono_time_point<std_chrono_steady_clock_duration>;
pub const std_chrono_steady_clock_is_steady: bool = true;
#[test]
fn bindgen_test_layout_std_chrono_steady_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_steady_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono_steady_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_steady_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono_steady_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12steady_clock3nowEv"]
    pub fn std_chrono_steady_clock_now() -> std_chrono_steady_clock_time_point;
}
impl std_chrono_steady_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_steady_clock_time_point {
        std_chrono_steady_clock_now()
    }
}
pub type std_chrono_high_resolution_clock = std_chrono_steady_clock;
pub const std___libcpp_polling_count: ::std::os::raw::c_int = 64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___spinning_backoff_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___spinning_backoff_policy() {
    assert_eq!(
        ::std::mem::size_of::<std___spinning_backoff_policy>(),
        1usize,
        concat!("Size of: ", stringify!(std___spinning_backoff_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___spinning_backoff_policy>(),
        1usize,
        concat!("Alignment of ", stringify!(std___spinning_backoff_policy))
    );
}
pub type std___libcpp_mutex_t = pthread_mutex_t;
pub type std___libcpp_recursive_mutex_t = pthread_mutex_t;
pub type std___libcpp_condvar_t = pthread_cond_t;
pub type std___libcpp_exec_once_flag = pthread_once_t;
pub type std___libcpp_thread_id = pthread_t;
pub type std___libcpp_thread_t = pthread_t;
pub type std___libcpp_tls_key = pthread_key_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_timed_backoff_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___libcpp_timed_backoff_policy() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_timed_backoff_policy>(),
        1usize,
        concat!("Size of: ", stringify!(std___libcpp_timed_backoff_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_timed_backoff_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___libcpp_timed_backoff_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___thread_id {
    pub __id_: std___libcpp_thread_id,
}
#[test]
fn bindgen_test_layout_std___thread_id() {
    assert_eq!(
        ::std::mem::size_of::<std___thread_id>(),
        8usize,
        concat!("Size of: ", stringify!(std___thread_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std___thread_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std___thread_id))
    );
    fn test_field___id_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___thread_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__id_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___thread_id),
                "::",
                stringify!(__id_)
            )
        );
    }
    test_field___id_();
}
pub const std___legacy_memory_order___mo_relaxed: std___legacy_memory_order = 0;
pub const std___legacy_memory_order___mo_consume: std___legacy_memory_order = 1;
pub const std___legacy_memory_order___mo_acquire: std___legacy_memory_order = 2;
pub const std___legacy_memory_order___mo_release: std___legacy_memory_order = 3;
pub const std___legacy_memory_order___mo_acq_rel: std___legacy_memory_order = 4;
pub const std___legacy_memory_order___mo_seq_cst: std___legacy_memory_order = 5;
pub type std___legacy_memory_order = ::std::os::raw::c_uint;
pub type std___memory_order_underlying_t = type_;
pub const std_memory_order_memory_order_relaxed: std_memory_order = 0;
pub const std_memory_order_memory_order_consume: std_memory_order = 1;
pub const std_memory_order_memory_order_acquire: std_memory_order = 2;
pub const std_memory_order_memory_order_release: std_memory_order = 3;
pub const std_memory_order_memory_order_acq_rel: std_memory_order = 4;
pub const std_memory_order_memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_uint;
#[repr(C)]
pub struct std___cxx_atomic_base_impl {
    pub __a_value: [u8; 0usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___cxx_atomic_impl<_Base> {
    pub _base: _Base,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Base>>,
}
pub type std___cxx_contention_t = i64;
pub type std___cxx_atomic_contention_t = std___cxx_atomic_impl<std___cxx_atomic_base_impl>;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_oneEPVKv"]
    pub fn std___cxx_atomic_notify_one(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_allEPVKv"]
    pub fn std___cxx_atomic_notify_all(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__libcpp_atomic_monitorEPVKv"]
    pub fn std___libcpp_atomic_monitor(
        arg1: *const ::std::os::raw::c_void,
    ) -> std___cxx_contention_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__120__libcpp_atomic_waitEPVKvx"]
    pub fn std___libcpp_atomic_wait(
        arg1: *const ::std::os::raw::c_void,
        arg2: std___cxx_contention_t,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_oneEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEE"]
    pub fn std___cxx_atomic_notify_one1(arg1: *const std___cxx_atomic_contention_t);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_allEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEE"]
    pub fn std___cxx_atomic_notify_all1(arg1: *const std___cxx_atomic_contention_t);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__libcpp_atomic_monitorEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEE"]
    pub fn std___libcpp_atomic_monitor1(
        arg1: *const std___cxx_atomic_contention_t,
    ) -> std___cxx_contention_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__120__libcpp_atomic_waitEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEEx"]
    pub fn std___libcpp_atomic_wait1(
        arg1: *const std___cxx_atomic_contention_t,
        arg2: std___cxx_contention_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_atomic_wait_backoff_impl<_Atp, _Fn> {
    pub __a: *mut _Atp,
    pub __test_fn: _Fn,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Atp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fn>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___cxx_atomic_wait_test_fn_impl<_Atp, _Tp> {
    pub __a: *mut _Atp,
    pub __val: _Tp,
    pub __order: std_memory_order,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Atp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic___base = u8;
pub type std_atomic_value_type<_Tp> = _Tp;
pub type std_atomic_difference_type<_Tp> = std_atomic_value_type<_Tp>;
#[repr(C)]
pub struct std_atomic_flag {
    pub __a_: std___cxx_atomic_impl<std___cxx_atomic_base_impl>,
}
#[test]
fn bindgen_test_layout_std_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(std_atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_atomic_flag))
    );
    fn test_field___a_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_atomic_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__a_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_atomic_flag),
                "::",
                stringify!(__a_)
            )
        );
    }
    test_field___a_();
}
pub type std_atomic_bool = std_atomic;
pub type std_atomic_char = std_atomic;
pub type std_atomic_schar = std_atomic;
pub type std_atomic_uchar = std_atomic;
pub type std_atomic_short = std_atomic;
pub type std_atomic_ushort = std_atomic;
pub type std_atomic_int = std_atomic;
pub type std_atomic_uint = std_atomic;
pub type std_atomic_long = std_atomic;
pub type std_atomic_ulong = std_atomic;
pub type std_atomic_llong = std_atomic;
pub type std_atomic_ullong = std_atomic;
pub type std_atomic_char16_t = std_atomic;
pub type std_atomic_char32_t = std_atomic;
pub type std_atomic_wchar_t = std_atomic;
pub type std_atomic_int_least8_t = std_atomic;
pub type std_atomic_uint_least8_t = std_atomic;
pub type std_atomic_int_least16_t = std_atomic;
pub type std_atomic_uint_least16_t = std_atomic;
pub type std_atomic_int_least32_t = std_atomic;
pub type std_atomic_uint_least32_t = std_atomic;
pub type std_atomic_int_least64_t = std_atomic;
pub type std_atomic_uint_least64_t = std_atomic;
pub type std_atomic_int_fast8_t = std_atomic;
pub type std_atomic_uint_fast8_t = std_atomic;
pub type std_atomic_int_fast16_t = std_atomic;
pub type std_atomic_uint_fast16_t = std_atomic;
pub type std_atomic_int_fast32_t = std_atomic;
pub type std_atomic_uint_fast32_t = std_atomic;
pub type std_atomic_int_fast64_t = std_atomic;
pub type std_atomic_uint_fast64_t = std_atomic;
pub type std_atomic_int8_t = std_atomic;
pub type std_atomic_uint8_t = std_atomic;
pub type std_atomic_int16_t = std_atomic;
pub type std_atomic_uint16_t = std_atomic;
pub type std_atomic_int32_t = std_atomic;
pub type std_atomic_uint32_t = std_atomic;
pub type std_atomic_int64_t = std_atomic;
pub type std_atomic_uint64_t = std_atomic;
pub type std_atomic_intptr_t = std_atomic;
pub type std_atomic_uintptr_t = std_atomic;
pub type std_atomic_size_t = std_atomic;
pub type std_atomic_ptrdiff_t = std_atomic;
pub type std_atomic_intmax_t = std_atomic;
pub type std_atomic_uintmax_t = std_atomic;
pub type std___libcpp_signed_lock_free = type_;
pub type std___libcpp_unsigned_lock_free = type_;
pub type std_atomic_signed_lock_free = std_atomic;
pub type std_atomic_unsigned_lock_free = std_atomic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_destructor<_Alloc> {
    pub __alloc_: *mut _Alloc,
    pub __s_: std___allocator_destructor_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___allocator_destructor___alloc_traits = std_allocator_traits;
pub type std___allocator_destructor_pointer = std___allocator_destructor___alloc_traits;
pub type std___allocator_destructor_size_type = std___allocator_destructor___alloc_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_weak_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_weak_ptr))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__112bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std___shared_count__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_count {
    pub vtable_: *const std___shared_count__bindgen_vtable,
    pub __shared_owners_: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std___shared_count() {
    assert_eq!(
        ::std::mem::size_of::<std___shared_count>(),
        16usize,
        concat!("Size of: ", stringify!(std___shared_count))
    );
    assert_eq!(
        ::std::mem::align_of::<std___shared_count>(),
        8usize,
        concat!("Alignment of ", stringify!(std___shared_count))
    );
    fn test_field___shared_owners_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___shared_count>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared_owners_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std___shared_count),
                "::",
                stringify!(__shared_owners_)
            )
        );
    }
    test_field___shared_owners_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__shared_countD1Ev"]
    pub fn std___shared_count___shared_count_destructor(this: *mut std___shared_count);
}
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_weak_count {
    pub _base: std___shared_count,
    pub __shared_weak_owners_: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std___shared_weak_count() {
    assert_eq!(
        ::std::mem::size_of::<std___shared_weak_count>(),
        24usize,
        concat!("Size of: ", stringify!(std___shared_weak_count))
    );
    assert_eq!(
        ::std::mem::align_of::<std___shared_weak_count>(),
        8usize,
        concat!("Alignment of ", stringify!(std___shared_weak_count))
    );
    fn test_field___shared_weak_owners_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___shared_weak_count>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared_weak_owners_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(std___shared_weak_count),
                "::",
                stringify!(__shared_weak_owners_)
            )
        );
    }
    test_field___shared_weak_owners_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119__shared_weak_count14__release_weakEv"]
    pub fn std___shared_weak_count___release_weak(this: *mut std___shared_weak_count);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119__shared_weak_count4lockEv"]
    pub fn std___shared_weak_count_lock(
        this: *mut std___shared_weak_count,
    ) -> *mut std___shared_weak_count;
}
impl std___shared_weak_count {
    #[inline]
    pub unsafe fn __release_weak(&mut self) {
        std___shared_weak_count___release_weak(self)
    }
    #[inline]
    pub unsafe fn lock(&mut self) -> *mut std___shared_weak_count {
        std___shared_weak_count_lock(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119__shared_weak_countD1Ev"]
    pub fn std___shared_weak_count___shared_weak_count_destructor(
        this: *mut std___shared_weak_count,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__119__shared_weak_count13__get_deleterERKSt9type_info"]
    pub fn std___shared_weak_count___get_deleter(
        this: *mut ::std::os::raw::c_void,
        arg1: *const std_type_info,
    ) -> *const ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_ptr_pointer {
    pub _base: std___shared_weak_count,
    pub __data_: std___compressed_pair,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_ptr_emplace {
    pub _base: std___shared_weak_count,
    pub __storage_: std___shared_ptr_emplace__Storage,
}
pub type std___shared_ptr_emplace__CompressedPair = std___compressed_pair;
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_ptr_emplace__Storage {
    pub __blob_: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr_dummy_rebind_allocator_type {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std___shared_ptr_dummy_rebind_allocator_type_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compatible_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_deletable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_deletable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___well_formed_deleter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr_deleter_ctor_reqs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr<_Tp> {
    pub __ptr_: *mut std_shared_ptr_element_type<_Tp>,
    pub __cntrl_: *mut std___shared_weak_count,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_shared_ptr_element_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr___shared_ptr_default_delete {
    pub _address: u8,
}
pub type std_shared_ptr___shared_ptr_default_allocator_type = std_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_weak_ptr<_Tp> {
    pub __ptr_: *mut std_weak_ptr_element_type<_Tp>,
    pub __cntrl_: *mut std___shared_weak_count,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_weak_ptr_element_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_enable_shared_from_this<_Tp> {
    pub __weak_this_: std_weak_ptr<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_mut {
    pub __lx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_std___sp_mut() {
    assert_eq!(
        ::std::mem::size_of::<std___sp_mut>(),
        8usize,
        concat!("Size of: ", stringify!(std___sp_mut))
    );
    assert_eq!(
        ::std::mem::align_of::<std___sp_mut>(),
        8usize,
        concat!("Alignment of ", stringify!(std___sp_mut))
    );
    fn test_field___lx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___sp_mut>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___sp_mut),
                "::",
                stringify!(__lx)
            )
        );
    }
    test_field___lx();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__sp_mut4lockEv"]
    pub fn std___sp_mut_lock(this: *mut std___sp_mut);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__sp_mut6unlockEv"]
    pub fn std___sp_mut_unlock(this: *mut std___sp_mut);
}
impl std___sp_mut {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std___sp_mut_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std___sp_mut_unlock(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__get_sp_mutEPKv"]
    pub fn std___get_sp_mut(arg1: *const ::std::os::raw::c_void) -> *mut std___sp_mut;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_back_insert_iterator_iterator_category = std_output_iterator_tag;
pub type std_back_insert_iterator_value_type = ::std::os::raw::c_void;
pub type std_back_insert_iterator_difference_type = ::std::os::raw::c_void;
pub type std_back_insert_iterator_pointer = ::std::os::raw::c_void;
pub type std_back_insert_iterator_reference = ::std::os::raw::c_void;
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_front_insert_iterator_iterator_category = std_output_iterator_tag;
pub type std_front_insert_iterator_value_type = ::std::os::raw::c_void;
pub type std_front_insert_iterator_difference_type = ::std::os::raw::c_void;
pub type std_front_insert_iterator_pointer = ::std::os::raw::c_void;
pub type std_front_insert_iterator_reference = ::std::os::raw::c_void;
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub iter: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_insert_iterator_iterator_category = std_output_iterator_tag;
pub type std_insert_iterator_value_type = ::std::os::raw::c_void;
pub type std_insert_iterator_difference_type = ::std::os::raw::c_void;
pub type std_insert_iterator_pointer = ::std::os::raw::c_void;
pub type std_insert_iterator_reference = ::std::os::raw::c_void;
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator<_CharT> {
    pub __sbuf_: *mut std_istreambuf_iterator_streambuf_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_istreambuf_iterator_iterator_category = std_input_iterator_tag;
pub type std_istreambuf_iterator_value_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_difference_type = [u8; 0usize];
pub type std_istreambuf_iterator_pointer<_CharT> = *mut _CharT;
pub type std_istreambuf_iterator_reference<_CharT> = _CharT;
pub type std_istreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_istreambuf_iterator_int_type = [u8; 0usize];
pub type std_istreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_istreambuf_iterator_istream_type = std_basic_istream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator___proxy<_CharT> {
    pub __keep_: std_istreambuf_iterator_char_type<_CharT>,
    pub __sbuf_: *mut std_istreambuf_iterator_streambuf_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istream_iterator<_Tp> {
    pub __in_stream_: *mut std_istream_iterator_istream_type,
    pub __value_: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_istream_iterator_iterator_category = std_input_iterator_tag;
pub type std_istream_iterator_value_type<_Tp> = _Tp;
pub type std_istream_iterator_difference_type<_Distance> = _Distance;
pub type std_istream_iterator_pointer<_Tp> = *const _Tp;
pub type std_istream_iterator_reference<_Tp> = *const _Tp;
pub type std_istream_iterator_char_type<_CharT> = _CharT;
pub type std_istream_iterator_traits_type<_Traits> = _Traits;
pub type std_istream_iterator_istream_type = std_basic_istream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iter> {
    pub __i: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_move_iterator_iterator_type<_Iter> = _Iter;
pub type std_move_iterator_value_type = std_iterator_traits;
pub type std_move_iterator_difference_type = std_iterator_traits;
pub type std_move_iterator_pointer<_Iter> = std_move_iterator_iterator_type<_Iter>;
pub type std_move_iterator_iterator_category = std__If;
pub type std_move_iterator_reference = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator<_CharT> {
    pub __sbuf_: *mut std_ostreambuf_iterator_streambuf_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_ostreambuf_iterator_iterator_category = std_output_iterator_tag;
pub type std_ostreambuf_iterator_value_type = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_difference_type = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_pointer = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_reference = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_ostreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_ostreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_ostreambuf_iterator_ostream_type = std_basic_ostream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostream_iterator<_CharT> {
    pub __out_stream_: *mut std_ostream_iterator_ostream_type,
    pub __delim_: *const std_ostream_iterator_char_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_ostream_iterator_iterator_category = std_output_iterator_tag;
pub type std_ostream_iterator_value_type = ::std::os::raw::c_void;
pub type std_ostream_iterator_difference_type = ::std::os::raw::c_void;
pub type std_ostream_iterator_pointer = ::std::os::raw::c_void;
pub type std_ostream_iterator_reference = ::std::os::raw::c_void;
pub type std_ostream_iterator_char_type<_CharT> = _CharT;
pub type std_ostream_iterator_traits_type<_Traits> = _Traits;
pub type std_ostream_iterator_ostream_type = std_basic_ostream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_stashing_iterator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub __t: _Iter,
    pub current: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_value_type = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutputIterator> {
    pub __x_: _OutputIterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_OutputIterator>>,
}
pub type std_raw_storage_iterator_iterator_category = std_output_iterator_tag;
pub type std_raw_storage_iterator_value_type = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_difference_type = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_pointer = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_reference = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___return_temporary_buffer {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___return_temporary_buffer() {
    assert_eq!(
        ::std::mem::size_of::<std___return_temporary_buffer>(),
        1usize,
        concat!("Size of: ", stringify!(std___return_temporary_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<std___return_temporary_buffer>(),
        1usize,
        concat!("Alignment of ", stringify!(std___return_temporary_buffer))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___destruct_n {
    pub __size_: size_t,
}
#[test]
fn bindgen_test_layout_std___destruct_n() {
    assert_eq!(
        ::std::mem::size_of::<std___destruct_n>(),
        8usize,
        concat!("Size of: ", stringify!(std___destruct_n))
    );
    assert_eq!(
        ::std::mem::align_of::<std___destruct_n>(),
        8usize,
        concat!("Alignment of ", stringify!(std___destruct_n))
    );
    fn test_field___size_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___destruct_n>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___destruct_n),
                "::",
                stringify!(__size_)
            )
        );
    }
    test_field___size_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15alignEmmRPvRm"]
    pub fn std_align(
        __align: size_t,
        __sz: size_t,
        __ptr: *mut *mut ::std::os::raw::c_void,
        __space: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___noexcept_move_assign_container {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___temp_value<_Alloc> {
    pub __v: u8,
    pub __a: *mut _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___temp_value__Traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_allocator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___builtin_new_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___builtin_new_allocator___builtin_new_deleter {
    pub __size_: size_t,
    pub __align_: size_t,
}
pub type std___builtin_new_allocator___builtin_new_deleter_pointer_type =
    *mut ::std::os::raw::c_void;
#[test]
fn bindgen_test_layout_std___builtin_new_allocator___builtin_new_deleter() {
    assert_eq!(
        ::std::mem::size_of::<std___builtin_new_allocator___builtin_new_deleter>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(std___builtin_new_allocator___builtin_new_deleter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___builtin_new_allocator___builtin_new_deleter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___builtin_new_allocator___builtin_new_deleter)
        )
    );
    fn test_field___size_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    std___builtin_new_allocator___builtin_new_deleter,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___builtin_new_allocator___builtin_new_deleter),
                "::",
                stringify!(__size_)
            )
        );
    }
    test_field___size_();
    fn test_field___align_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    std___builtin_new_allocator___builtin_new_deleter,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std___builtin_new_allocator___builtin_new_deleter),
                "::",
                stringify!(__align_)
            )
        );
    }
    test_field___align_();
}
pub type std___builtin_new_allocator___holder_t = std_unique_ptr;
#[test]
fn bindgen_test_layout_std___builtin_new_allocator() {
    assert_eq!(
        ::std::mem::size_of::<std___builtin_new_allocator>(),
        1usize,
        concat!("Size of: ", stringify!(std___builtin_new_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<std___builtin_new_allocator>(),
        1usize,
        concat!("Alignment of ", stringify!(std___builtin_new_allocator))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_function_call {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_function_call() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_function_call>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_function_call))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_function_call>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_function_call))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___maybe_derive_from_unary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___maybe_derive_from_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___func {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___mem_fn<_Tp> {
    pub __f_: std___mem_fn_type<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std___mem_fn_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub __f_: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1, arg2: _Arg2) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg2>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub __f_: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub __pred_: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___comp_ref_type {
    pub _address: u8,
}
pub type std___comp_ref_type_type = std_add_lvalue_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invert<_Predicate> {
    pub __p_: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___log2_imp_value: size_t;
}
#[repr(C)]
pub struct std___independent_bits_engine<_Engine> {
    pub __e_: *mut _Engine,
    pub __w_: size_t,
    pub __w0_: size_t,
    pub __n_: size_t,
    pub __n0_: size_t,
    pub __y0_: std___independent_bits_engine__Working_result_type,
    pub __y1_: std___independent_bits_engine__Working_result_type,
    pub __mask0_: std___independent_bits_engine__Engine_result_type,
    pub __mask1_: std___independent_bits_engine__Engine_result_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Engine>>,
}
pub type std___independent_bits_engine_result_type<_UIntType> = _UIntType;
pub type std___independent_bits_engine__Engine_result_type = [u8; 0usize];
pub type std___independent_bits_engine__Working_result_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub __p_: std_uniform_int_distribution_param_type<_IntType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub __a_: std_uniform_int_distribution_result_type<_IntType>,
    pub __b_: std_uniform_int_distribution_result_type<_IntType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__rs_getEv"]
    pub fn std___rs_get() -> std___rs_default;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___rs_default {
    pub _address: u8,
}
pub type std___rs_default_result_type = uint_fast32_t;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__rs_default4__c_E"]
    pub static mut std___rs_default___c_: ::std::os::raw::c_uint;
}
pub const std___rs_default__Min: std___rs_default_result_type = 0;
pub const std___rs_default__Max: std___rs_default_result_type = 4294967295;
#[test]
fn bindgen_test_layout_std___rs_default() {
    assert_eq!(
        ::std::mem::size_of::<std___rs_default>(),
        1usize,
        concat!("Size of: ", stringify!(std___rs_default))
    );
    assert_eq!(
        ::std::mem::align_of::<std___rs_default>(),
        1usize,
        concat!("Alignment of ", stringify!(std___rs_default))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__rs_defaultC1ERKS0_"]
    pub fn std___rs_default___rs_default(
        this: *mut std___rs_default,
        arg1: *const std___rs_default,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__rs_defaultD1Ev"]
    pub fn std___rs_default___rs_default_destructor(this: *mut std___rs_default);
}
impl std___rs_default {
    #[inline]
    pub unsafe fn new(arg1: *const std___rs_default) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___rs_default___rs_default(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___rs_default___rs_default_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___stable_sort_switch {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_char_traits_char_type<_CharT> = _CharT;
pub type std_char_traits_int_type = ::std::os::raw::c_int;
pub type std_char_traits_off_type = std_streamoff;
pub type std_char_traits_pos_type = std_streampos;
pub type std_char_traits_state_type = mbstate_t;
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___quoted_output_proxy<_CharT, _Iter> {
    pub __first: _Iter,
    pub __last: _Iter,
    pub __delim: _CharT,
    pub __escape: _CharT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_string_view = std_basic_string_view<::std::os::raw::c_char>;
pub type std_u16string_view = std_basic_string_view<char16_t>;
pub type std_u32string_view = std_basic_string_view<char32_t>;
pub type std_wstring_view = std_basic_string_view<u32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub __data: *const std_basic_string_view_value_type<_CharT>,
    pub __size: std_basic_string_view_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_pointer<_CharT> = *const _CharT;
pub type std_basic_string_view_reference<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_reference<_CharT> = *const _CharT;
pub type std_basic_string_view_const_iterator<_CharT> = std_basic_string_view_const_pointer<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = size_t;
pub type std_basic_string_view_difference_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub __st_: _StateT,
    pub __off_: std_streamoff,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
extern "C" {
    #[link_name = "\u{1}__throw_length_error"]
    pub fn std___basic_string_common___throw_length_error(this: *const u8);
}
extern "C" {
    #[link_name = "\u{1}__throw_out_of_range"]
    pub fn std___basic_string_common___throw_out_of_range(this: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___string_is_trivial_iterator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_be_converted_to_string_view {
    pub _address: u8,
}
pub type std_u16string = std_basic_string;
pub type std_u32string = std_basic_string;
#[repr(C)]
pub struct std_basic_string {
    pub _base: u8,
    pub __r_: std___compressed_pair,
}
pub type std_basic_string___self = std_basic_string;
pub type std_basic_string___self_view<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type<_CharT> = _CharT;
pub type std_basic_string_allocator_type<_Allocator> = _Allocator;
pub type std_basic_string___alloc_traits = std_allocator_traits;
pub type std_basic_string_size_type = std_basic_string___alloc_traits;
pub type std_basic_string_difference_type = std_basic_string___alloc_traits;
pub type std_basic_string_reference<_CharT> = *mut std_basic_string_value_type<_CharT>;
pub type std_basic_string_const_reference<_CharT> = *const std_basic_string_value_type<_CharT>;
pub type std_basic_string_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_iterator = std___wrap_iter<std_basic_string_pointer>;
pub type std_basic_string_const_iterator = std___wrap_iter<std_basic_string_const_pointer>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___long {
    pub __data_: std_basic_string_pointer,
    pub __size_: std_basic_string_size_type,
    pub __cap_: std_basic_string_size_type,
}
pub const std_basic_string___min_cap: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short<_CharT> {
    pub __data_: *mut std_basic_string_value_type<_CharT>,
    pub __bindgen_anon_1: std_basic_string___short__bindgen_ty_1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short__bindgen_ty_1 {
    pub __size_: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___ulx<_CharT> {
    pub __lx: __BindgenUnionField<std_basic_string___long>,
    pub __lxx: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub const std_basic_string___n_words: std_basic_string__bindgen_ty_2 = 0;
pub type std_basic_string__bindgen_ty_2 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___raw {
    pub __words: *mut std_basic_string_size_type,
}
#[repr(C)]
pub struct std_basic_string___rep<_CharT> {
    pub __bindgen_anon_1: std_basic_string___rep__bindgen_ty_1<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___rep__bindgen_ty_1<_CharT> {
    pub __l: __BindgenUnionField<std_basic_string___long>,
    pub __s: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub __r: __BindgenUnionField<std_basic_string___raw>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub const std_basic_string___alignment: std_basic_string__bindgen_ty_3 = 0;
pub type std_basic_string__bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traits_eq {
    pub _address: u8,
}
pub type std___traits_eq_char_type = [u8; 0usize];
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stoiERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPmi"]
    pub fn std_stoi(
        __str: *const std_string,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stolERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPmi"]
    pub fn std_stol(
        __str: *const std_string,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15stoulERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPmi"]
    pub fn std_stoul(
        __str: *const std_string,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15stollERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPmi"]
    pub fn std_stoll(
        __str: *const std_string,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16stoullERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPmi"]
    pub fn std_stoull(
        __str: *const std_string,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stofERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPm"]
    pub fn std_stof(__str: *const std_string, __idx: *mut size_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stodERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPm"]
    pub fn std_stod(__str: *const std_string, __idx: *mut size_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15stoldERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPm"]
    pub fn std_stold(__str: *const std_string, __idx: *mut size_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEi"]
    pub fn std_to_string(__val: ::std::os::raw::c_int) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEj"]
    pub fn std_to_string1(__val: ::std::os::raw::c_uint) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEl"]
    pub fn std_to_string2(__val: ::std::os::raw::c_long) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEm"]
    pub fn std_to_string3(__val: ::std::os::raw::c_ulong) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEx"]
    pub fn std_to_string4(__val: ::std::os::raw::c_longlong) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEy"]
    pub fn std_to_string5(__val: ::std::os::raw::c_ulonglong) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEf"]
    pub fn std_to_string6(__val: f32) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEd"]
    pub fn std_to_string7(__val: f64) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__19to_stringEe"]
    pub fn std_to_string8(__val: f64) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stoiERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPmi"]
    pub fn std_stoi1(
        __str: *const std_wstring,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stolERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPmi"]
    pub fn std_stol1(
        __str: *const std_wstring,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15stoulERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPmi"]
    pub fn std_stoul1(
        __str: *const std_wstring,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15stollERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPmi"]
    pub fn std_stoll1(
        __str: *const std_wstring,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16stoullERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPmi"]
    pub fn std_stoull1(
        __str: *const std_wstring,
        __idx: *mut size_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stofERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPm"]
    pub fn std_stof1(__str: *const std_wstring, __idx: *mut size_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14stodERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPm"]
    pub fn std_stod1(__str: *const std_wstring, __idx: *mut size_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15stoldERKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEEPm"]
    pub fn std_stold1(__str: *const std_wstring, __idx: *mut size_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEi"]
    pub fn std_to_wstring(__val: ::std::os::raw::c_int) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEj"]
    pub fn std_to_wstring1(__val: ::std::os::raw::c_uint) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEl"]
    pub fn std_to_wstring2(__val: ::std::os::raw::c_long) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEm"]
    pub fn std_to_wstring3(__val: ::std::os::raw::c_ulong) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEx"]
    pub fn std_to_wstring4(__val: ::std::os::raw::c_longlong) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEy"]
    pub fn std_to_wstring5(__val: ::std::os::raw::c_ulonglong) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEf"]
    pub fn std_to_wstring6(__val: f32) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEd"]
    pub fn std_to_wstring7(__val: f64) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110to_wstringEe"]
    pub fn std_to_wstring8(__val: f64) -> std_wstring;
}
extern "C" {
    #[link_name = "\u{1}npos"]
    pub static std_npos: std_basic_string_size_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_errc {
    pub __v_: std_errc___lx,
}
pub const std_errc___lx_address_family_not_supported: std_errc___lx = 47;
pub const std_errc___lx_address_in_use: std_errc___lx = 48;
pub const std_errc___lx_address_not_available: std_errc___lx = 49;
pub const std_errc___lx_already_connected: std_errc___lx = 56;
pub const std_errc___lx_argument_list_too_long: std_errc___lx = 7;
pub const std_errc___lx_argument_out_of_domain: std_errc___lx = 33;
pub const std_errc___lx_bad_address: std_errc___lx = 14;
pub const std_errc___lx_bad_file_descriptor: std_errc___lx = 9;
pub const std_errc___lx_bad_message: std_errc___lx = 94;
pub const std_errc___lx_broken_pipe: std_errc___lx = 32;
pub const std_errc___lx_connection_aborted: std_errc___lx = 53;
pub const std_errc___lx_connection_already_in_progress: std_errc___lx = 37;
pub const std_errc___lx_connection_refused: std_errc___lx = 61;
pub const std_errc___lx_connection_reset: std_errc___lx = 54;
pub const std_errc___lx_cross_device_link: std_errc___lx = 18;
pub const std_errc___lx_destination_address_required: std_errc___lx = 39;
pub const std_errc___lx_device_or_resource_busy: std_errc___lx = 16;
pub const std_errc___lx_directory_not_empty: std_errc___lx = 66;
pub const std_errc___lx_executable_format_error: std_errc___lx = 8;
pub const std_errc___lx_file_exists: std_errc___lx = 17;
pub const std_errc___lx_file_too_large: std_errc___lx = 27;
pub const std_errc___lx_filename_too_long: std_errc___lx = 63;
pub const std_errc___lx_function_not_supported: std_errc___lx = 78;
pub const std_errc___lx_host_unreachable: std_errc___lx = 65;
pub const std_errc___lx_identifier_removed: std_errc___lx = 90;
pub const std_errc___lx_illegal_byte_sequence: std_errc___lx = 92;
pub const std_errc___lx_inappropriate_io_control_operation: std_errc___lx = 25;
pub const std_errc___lx_interrupted: std_errc___lx = 4;
pub const std_errc___lx_invalid_argument: std_errc___lx = 22;
pub const std_errc___lx_invalid_seek: std_errc___lx = 29;
pub const std_errc___lx_io_error: std_errc___lx = 5;
pub const std_errc___lx_is_a_directory: std_errc___lx = 21;
pub const std_errc___lx_message_size: std_errc___lx = 40;
pub const std_errc___lx_network_down: std_errc___lx = 50;
pub const std_errc___lx_network_reset: std_errc___lx = 52;
pub const std_errc___lx_network_unreachable: std_errc___lx = 51;
pub const std_errc___lx_no_buffer_space: std_errc___lx = 55;
pub const std_errc___lx_no_child_process: std_errc___lx = 10;
pub const std_errc___lx_no_link: std_errc___lx = 97;
pub const std_errc___lx_no_lock_available: std_errc___lx = 77;
pub const std_errc___lx_no_message_available: std_errc___lx = 96;
pub const std_errc___lx_no_message: std_errc___lx = 91;
pub const std_errc___lx_no_protocol_option: std_errc___lx = 42;
pub const std_errc___lx_no_space_on_device: std_errc___lx = 28;
pub const std_errc___lx_no_stream_resources: std_errc___lx = 98;
pub const std_errc___lx_no_such_device_or_address: std_errc___lx = 6;
pub const std_errc___lx_no_such_device: std_errc___lx = 19;
pub const std_errc___lx_no_such_file_or_directory: std_errc___lx = 2;
pub const std_errc___lx_no_such_process: std_errc___lx = 3;
pub const std_errc___lx_not_a_directory: std_errc___lx = 20;
pub const std_errc___lx_not_a_socket: std_errc___lx = 38;
pub const std_errc___lx_not_a_stream: std_errc___lx = 99;
pub const std_errc___lx_not_connected: std_errc___lx = 57;
pub const std_errc___lx_not_enough_memory: std_errc___lx = 12;
pub const std_errc___lx_not_supported: std_errc___lx = 45;
pub const std_errc___lx_operation_canceled: std_errc___lx = 89;
pub const std_errc___lx_operation_in_progress: std_errc___lx = 36;
pub const std_errc___lx_operation_not_permitted: std_errc___lx = 1;
pub const std_errc___lx_operation_not_supported: std_errc___lx = 102;
pub const std_errc___lx_operation_would_block: std_errc___lx = 35;
pub const std_errc___lx_owner_dead: std_errc___lx = 105;
pub const std_errc___lx_permission_denied: std_errc___lx = 13;
pub const std_errc___lx_protocol_error: std_errc___lx = 100;
pub const std_errc___lx_protocol_not_supported: std_errc___lx = 43;
pub const std_errc___lx_read_only_file_system: std_errc___lx = 30;
pub const std_errc___lx_resource_deadlock_would_occur: std_errc___lx = 11;
pub const std_errc___lx_resource_unavailable_try_again: std_errc___lx = 35;
pub const std_errc___lx_result_out_of_range: std_errc___lx = 34;
pub const std_errc___lx_state_not_recoverable: std_errc___lx = 104;
pub const std_errc___lx_stream_timeout: std_errc___lx = 101;
pub const std_errc___lx_text_file_busy: std_errc___lx = 26;
pub const std_errc___lx_timed_out: std_errc___lx = 60;
pub const std_errc___lx_too_many_files_open_in_system: std_errc___lx = 23;
pub const std_errc___lx_too_many_files_open: std_errc___lx = 24;
pub const std_errc___lx_too_many_links: std_errc___lx = 31;
pub const std_errc___lx_too_many_symbolic_link_levels: std_errc___lx = 62;
pub const std_errc___lx_value_too_large: std_errc___lx = 84;
pub const std_errc___lx_wrong_protocol_type: std_errc___lx = 41;
pub type std_errc___lx = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_std_errc() {
    assert_eq!(
        ::std::mem::size_of::<std_errc>(),
        4usize,
        concat!("Size of: ", stringify!(std_errc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_errc>(),
        4usize,
        concat!("Alignment of ", stringify!(std_errc))
    );
    fn test_field___v_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_errc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_errc),
                "::",
                stringify!(__v_)
            )
        );
    }
    test_field___v_();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_code_enum {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_condition_enum {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_is_error_condition_enum_open0_std_errc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_error_condition_enum_open0_std_errc___lx_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
}
#[repr(C)]
pub struct std_error_category__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_error_category {
    pub vtable_: *const std_error_category__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_error_category() {
    assert_eq!(
        ::std::mem::size_of::<std_error_category>(),
        8usize,
        concat!("Size of: ", stringify!(std_error_category))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_category>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_category))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114error_categoryD1Ev"]
    pub fn std_error_category_error_category_destructor(this: *mut std_error_category);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__114error_category23default_error_conditionEi"]
    pub fn std_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __ev: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__114error_category10equivalentEiRKNS_15error_conditionE"]
    pub fn std_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __code: ::std::os::raw::c_int,
        __condition: *const std_error_condition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__114error_category10equivalentERKNS_10error_codeEi"]
    pub fn std_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __condition: ::std::os::raw::c_int,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___do_message {
    pub _base: std_error_category,
}
#[test]
fn bindgen_test_layout_std___do_message() {
    assert_eq!(
        ::std::mem::size_of::<std___do_message>(),
        8usize,
        concat!("Size of: ", stringify!(std___do_message))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_message>(),
        8usize,
        concat!("Alignment of ", stringify!(std___do_message))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__116generic_categoryEv"]
    pub fn std_generic_category() -> *const std_error_category;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__115system_categoryEv"]
    pub fn std_system_category() -> *const std_error_category;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub __val_: ::std::os::raw::c_int,
    pub __cat_: *const std_error_category,
}
#[test]
fn bindgen_test_layout_std_error_condition() {
    assert_eq!(
        ::std::mem::size_of::<std_error_condition>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_condition))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_condition>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_condition))
    );
    fn test_field___val_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_error_condition>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_error_condition),
                "::",
                stringify!(__val_)
            )
        );
    }
    test_field___val_();
    fn test_field___cat_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_error_condition>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cat_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_error_condition),
                "::",
                stringify!(__cat_)
            )
        );
    }
    test_field___cat_();
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__115error_condition7messageEv"]
    pub fn std_error_condition_message(this: *const std_error_condition) -> std_string;
}
impl std_error_condition {
    #[inline]
    pub unsafe fn message(&self) -> std_string {
        std_error_condition_message(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub __val_: ::std::os::raw::c_int,
    pub __cat_: *const std_error_category,
}
#[test]
fn bindgen_test_layout_std_error_code() {
    assert_eq!(
        ::std::mem::size_of::<std_error_code>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_code))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_code>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_code))
    );
    fn test_field___val_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_error_code>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_error_code),
                "::",
                stringify!(__val_)
            )
        );
    }
    test_field___val_();
    fn test_field___cat_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_error_code>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cat_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_error_code),
                "::",
                stringify!(__cat_)
            )
        );
    }
    test_field___cat_();
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__110error_code7messageEv"]
    pub fn std_error_code_message(this: *const std_error_code) -> std_string;
}
impl std_error_code {
    #[inline]
    pub unsafe fn message(&self) -> std_string {
        std_error_code_message(self)
    }
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_error_code_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_error_condition_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_system_error {
    pub _base: std_runtime_error,
    pub __ec_: std_error_code,
}
#[test]
fn bindgen_test_layout_std_system_error() {
    assert_eq!(
        ::std::mem::size_of::<std_system_error>(),
        32usize,
        concat!("Size of: ", stringify!(std_system_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_system_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_system_error))
    );
    fn test_field___ec_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_system_error>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ec_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(std_system_error),
                "::",
                stringify!(__ec_)
            )
        );
    }
    test_field___ec_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorC1ENS_10error_codeERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"]
    pub fn std_system_error_system_error(
        this: *mut std_system_error,
        __ec: std_error_code,
        __what_arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorC1ENS_10error_codeEPKc"]
    pub fn std_system_error_system_error1(
        this: *mut std_system_error,
        __ec: std_error_code,
        __what_arg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorC1ENS_10error_codeE"]
    pub fn std_system_error_system_error2(this: *mut std_system_error, __ec: std_error_code);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorC1EiRKNS_14error_categoryERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"]
    pub fn std_system_error_system_error3(
        this: *mut std_system_error,
        __ev: ::std::os::raw::c_int,
        __ecat: *const std_error_category,
        __what_arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorC1EiRKNS_14error_categoryEPKc"]
    pub fn std_system_error_system_error4(
        this: *mut std_system_error,
        __ev: ::std::os::raw::c_int,
        __ecat: *const std_error_category,
        __what_arg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorC1EiRKNS_14error_categoryE"]
    pub fn std_system_error_system_error5(
        this: *mut std_system_error,
        __ev: ::std::os::raw::c_int,
        __ecat: *const std_error_category,
    );
}
impl std_system_error {
    #[inline]
    pub unsafe fn new(__ec: std_error_code, __what_arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_system_error_system_error(__bindgen_tmp.as_mut_ptr(), __ec, __what_arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__ec: std_error_code, __what_arg: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_system_error_system_error1(__bindgen_tmp.as_mut_ptr(), __ec, __what_arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(__ec: std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_system_error_system_error2(__bindgen_tmp.as_mut_ptr(), __ec);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        __ev: ::std::os::raw::c_int,
        __ecat: *const std_error_category,
        __what_arg: *const std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_system_error_system_error3(__bindgen_tmp.as_mut_ptr(), __ev, __ecat, __what_arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        __ev: ::std::os::raw::c_int,
        __ecat: *const std_error_category,
        __what_arg: *const ::std::os::raw::c_char,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_system_error_system_error4(__bindgen_tmp.as_mut_ptr(), __ev, __ecat, __what_arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(__ev: ::std::os::raw::c_int, __ecat: *const std_error_category) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_system_error_system_error5(__bindgen_tmp.as_mut_ptr(), __ev, __ecat);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112system_errorD1Ev"]
    pub fn std_system_error_system_error_destructor(this: *mut std_system_error);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__120__throw_system_errorEiPKc"]
    pub fn std___throw_system_error(
        ev: ::std::os::raw::c_int,
        what_arg: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_mutex {
    pub __m_: std___libcpp_mutex_t,
}
pub type std_mutex_native_handle_type = *mut std___libcpp_mutex_t;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_mutex>(),
        64usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
    fn test_field___m_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__m_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_mutex),
                "::",
                stringify!(__m_)
            )
        );
    }
    test_field___m_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15mutex4lockEv"]
    pub fn std_mutex_lock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15mutex8try_lockEv"]
    pub fn std_mutex_try_lock(this: *mut std_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15mutex6unlockEv"]
    pub fn std_mutex_unlock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15mutexD1Ev"]
    pub fn std_mutex_mutex_destructor(this: *mut std_mutex);
}
impl std_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_mutex_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_defer_lock_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_defer_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<std_defer_lock_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_defer_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_defer_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_defer_lock_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_try_to_lock_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_try_to_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<std_try_to_lock_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_try_to_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_try_to_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_try_to_lock_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_adopt_lock_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_adopt_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<std_adopt_lock_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_adopt_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_adopt_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_adopt_lock_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110defer_lockE"]
    pub static std_defer_lock: std_defer_lock_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111try_to_lockE"]
    pub static std_try_to_lock: std_try_to_lock_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110adopt_lockE"]
    pub static std_adopt_lock: std_adopt_lock_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_lock_guard<_Mutex> {
    pub __m_: *mut std_lock_guard_mutex_type<_Mutex>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Mutex>>,
}
pub type std_lock_guard_mutex_type<_Mutex> = _Mutex;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_lock<_Mutex> {
    pub __m_: *mut std_unique_lock_mutex_type<_Mutex>,
    pub __owns_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Mutex>>,
}
pub type std_unique_lock_mutex_type<_Mutex> = _Mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_cv_status {
    pub __v_: std_cv_status___lx,
}
pub const std_cv_status___lx_no_timeout: std_cv_status___lx = 0;
pub const std_cv_status___lx_timeout: std_cv_status___lx = 1;
pub type std_cv_status___lx = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_std_cv_status() {
    assert_eq!(
        ::std::mem::size_of::<std_cv_status>(),
        4usize,
        concat!("Size of: ", stringify!(std_cv_status))
    );
    assert_eq!(
        ::std::mem::align_of::<std_cv_status>(),
        4usize,
        concat!("Alignment of ", stringify!(std_cv_status))
    );
    fn test_field___v_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_cv_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_cv_status),
                "::",
                stringify!(__v_)
            )
        );
    }
    test_field___v_();
}
#[repr(C)]
#[derive(Debug)]
pub struct std_condition_variable {
    pub __cv_: std___libcpp_condvar_t,
}
pub type std_condition_variable_native_handle_type = *mut std___libcpp_condvar_t;
#[test]
fn bindgen_test_layout_std_condition_variable() {
    assert_eq!(
        ::std::mem::size_of::<std_condition_variable>(),
        48usize,
        concat!("Size of: ", stringify!(std_condition_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<std_condition_variable>(),
        8usize,
        concat!("Alignment of ", stringify!(std_condition_variable))
    );
    fn test_field___cv_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_condition_variable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cv_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_condition_variable),
                "::",
                stringify!(__cv_)
            )
        );
    }
    test_field___cv_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__118condition_variable10notify_oneEv"]
    pub fn std_condition_variable_notify_one(this: *mut std_condition_variable);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__118condition_variable10notify_allEv"]
    pub fn std_condition_variable_notify_all(this: *mut std_condition_variable);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__118condition_variable4waitERNS_11unique_lockINS_5mutexEEE"]
    pub fn std_condition_variable_wait(
        this: *mut std_condition_variable,
        __lk: *mut std_unique_lock<std_mutex>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__118condition_variableD1Ev"]
    pub fn std_condition_variable_condition_variable_destructor(this: *mut std_condition_variable);
}
impl std_condition_variable {
    #[inline]
    pub unsafe fn notify_one(&mut self) {
        std_condition_variable_notify_one(self)
    }
    #[inline]
    pub unsafe fn notify_all(&mut self) {
        std_condition_variable_notify_all(self)
    }
    #[inline]
    pub unsafe fn wait(&mut self, __lk: *mut std_unique_lock<std_mutex>) {
        std_condition_variable_wait(self, __lk)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_condition_variable_condition_variable_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_recursive_mutex {
    pub __m_: std___libcpp_recursive_mutex_t,
}
pub type std_recursive_mutex_native_handle_type = *mut std___libcpp_recursive_mutex_t;
#[test]
fn bindgen_test_layout_std_recursive_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_recursive_mutex>(),
        64usize,
        concat!("Size of: ", stringify!(std_recursive_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_recursive_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_recursive_mutex))
    );
    fn test_field___m_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_recursive_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__m_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_recursive_mutex),
                "::",
                stringify!(__m_)
            )
        );
    }
    test_field___m_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__115recursive_mutex4lockEv"]
    pub fn std_recursive_mutex_lock(this: *mut std_recursive_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__115recursive_mutex8try_lockEv"]
    pub fn std_recursive_mutex_try_lock(this: *mut std_recursive_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__115recursive_mutex6unlockEv"]
    pub fn std_recursive_mutex_unlock(this: *mut std_recursive_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__115recursive_mutexC1Ev"]
    pub fn std_recursive_mutex_recursive_mutex(this: *mut std_recursive_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__115recursive_mutexD1Ev"]
    pub fn std_recursive_mutex_recursive_mutex_destructor(this: *mut std_recursive_mutex);
}
impl std_recursive_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_recursive_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_recursive_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_recursive_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_recursive_mutex_recursive_mutex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_recursive_mutex_recursive_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_timed_mutex {
    pub __m_: std_mutex,
    pub __cv_: std_condition_variable,
    pub __locked_: bool,
}
#[test]
fn bindgen_test_layout_std_timed_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_timed_mutex>(),
        120usize,
        concat!("Size of: ", stringify!(std_timed_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_timed_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_timed_mutex))
    );
    fn test_field___m_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__m_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_timed_mutex),
                "::",
                stringify!(__m_)
            )
        );
    }
    test_field___m_();
    fn test_field___cv_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cv_) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(std_timed_mutex),
                "::",
                stringify!(__cv_)
            )
        );
    }
    test_field___cv_();
    fn test_field___locked_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locked_) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(std_timed_mutex),
                "::",
                stringify!(__locked_)
            )
        );
    }
    test_field___locked_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111timed_mutex4lockEv"]
    pub fn std_timed_mutex_lock(this: *mut std_timed_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111timed_mutex8try_lockEv"]
    pub fn std_timed_mutex_try_lock(this: *mut std_timed_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111timed_mutex6unlockEv"]
    pub fn std_timed_mutex_unlock(this: *mut std_timed_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111timed_mutexC1Ev"]
    pub fn std_timed_mutex_timed_mutex(this: *mut std_timed_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111timed_mutexD1Ev"]
    pub fn std_timed_mutex_timed_mutex_destructor(this: *mut std_timed_mutex);
}
impl std_timed_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_timed_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_timed_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_timed_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_timed_mutex_timed_mutex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_timed_mutex_timed_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_recursive_timed_mutex {
    pub __m_: std_mutex,
    pub __cv_: std_condition_variable,
    pub __count_: size_t,
    pub __id_: std___thread_id,
}
#[test]
fn bindgen_test_layout_std_recursive_timed_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_recursive_timed_mutex>(),
        128usize,
        concat!("Size of: ", stringify!(std_recursive_timed_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_recursive_timed_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_recursive_timed_mutex))
    );
    fn test_field___m_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_recursive_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__m_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_recursive_timed_mutex),
                "::",
                stringify!(__m_)
            )
        );
    }
    test_field___m_();
    fn test_field___cv_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_recursive_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cv_) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(std_recursive_timed_mutex),
                "::",
                stringify!(__cv_)
            )
        );
    }
    test_field___cv_();
    fn test_field___count_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_recursive_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count_) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(std_recursive_timed_mutex),
                "::",
                stringify!(__count_)
            )
        );
    }
    test_field___count_();
    fn test_field___id_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_recursive_timed_mutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__id_) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(std_recursive_timed_mutex),
                "::",
                stringify!(__id_)
            )
        );
    }
    test_field___id_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121recursive_timed_mutex4lockEv"]
    pub fn std_recursive_timed_mutex_lock(this: *mut std_recursive_timed_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121recursive_timed_mutex8try_lockEv"]
    pub fn std_recursive_timed_mutex_try_lock(this: *mut std_recursive_timed_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121recursive_timed_mutex6unlockEv"]
    pub fn std_recursive_timed_mutex_unlock(this: *mut std_recursive_timed_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121recursive_timed_mutexC1Ev"]
    pub fn std_recursive_timed_mutex_recursive_timed_mutex(this: *mut std_recursive_timed_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121recursive_timed_mutexD1Ev"]
    pub fn std_recursive_timed_mutex_recursive_timed_mutex_destructor(
        this: *mut std_recursive_timed_mutex,
    );
}
impl std_recursive_timed_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_recursive_timed_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_recursive_timed_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_recursive_timed_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_recursive_timed_mutex_recursive_timed_mutex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_recursive_timed_mutex_recursive_timed_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_once_flag {
    pub __state_: std_once_flag__State_type,
}
pub type std_once_flag__State_type = ::std::os::raw::c_ulong;
#[test]
fn bindgen_test_layout_std_once_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_once_flag>(),
        8usize,
        concat!("Size of: ", stringify!(std_once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_once_flag>(),
        8usize,
        concat!("Alignment of ", stringify!(std_once_flag))
    );
    fn test_field___state_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_once_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_once_flag),
                "::",
                stringify!(__state_)
            )
        );
    }
    test_field___state_();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_once_param<_Fp> {
    pub __f_: *mut _Fp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fp>>,
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__111__call_onceERVmPvPFvS2_E"]
    pub fn std___call_once(
        arg1: *mut std_once_flag__State_type,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale {
    pub __locale_: *mut std_locale___imp,
}
pub type std_locale_category = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale___imp {
    _unused: [u8; 0],
}
pub const std_locale_none: std_locale_category = 0;
pub const std_locale_collate: std_locale_category = 1;
pub const std_locale_ctype: std_locale_category = 2;
pub const std_locale_monetary: std_locale_category = 8;
pub const std_locale_numeric: std_locale_category = 16;
pub const std_locale_time: std_locale_category = 32;
pub const std_locale_messages: std_locale_category = 4;
pub const std_locale_all: std_locale_category = 63;
#[test]
fn bindgen_test_layout_std_locale() {
    assert_eq!(
        ::std::mem::size_of::<std_locale>(),
        8usize,
        concat!("Size of: ", stringify!(std_locale))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale))
    );
    fn test_field___locale_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_locale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locale_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_locale),
                "::",
                stringify!(__locale_)
            )
        );
    }
    test_field___locale_();
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__16locale4nameEv"]
    pub fn std_locale_name(this: *const std_locale) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16locale6globalERKS0_"]
    pub fn std_locale_global(arg1: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16locale7classicEv"]
    pub fn std_locale_classic() -> *const std_locale;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1Ev"]
    pub fn std_locale_locale(this: *mut std_locale);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1ERKS0_"]
    pub fn std_locale_locale1(this: *mut std_locale, arg1: *const std_locale);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1EPKc"]
    pub fn std_locale_locale2(this: *mut std_locale, arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"]
    pub fn std_locale_locale3(this: *mut std_locale, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1ERKS0_PKci"]
    pub fn std_locale_locale4(
        this: *mut std_locale,
        arg1: *const std_locale,
        arg2: *const ::std::os::raw::c_char,
        arg3: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1ERKS0_RKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEi"]
    pub fn std_locale_locale5(
        this: *mut std_locale,
        arg1: *const std_locale,
        arg2: *const std_string,
        arg3: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeC1ERKS0_S2_i"]
    pub fn std_locale_locale6(
        this: *mut std_locale,
        arg1: *const std_locale,
        arg2: *const std_locale,
        arg3: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16localeD1Ev"]
    pub fn std_locale_locale_destructor(this: *mut std_locale);
}
impl std_locale {
    #[inline]
    pub unsafe fn name(&self) -> std_string {
        std_locale_name(self)
    }
    #[inline]
    pub unsafe fn global(arg1: *const std_locale) -> std_locale {
        std_locale_global(arg1)
    }
    #[inline]
    pub unsafe fn classic() -> *const std_locale {
        std_locale_classic()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_locale) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        arg1: *const std_locale,
        arg2: *const ::std::os::raw::c_char,
        arg3: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale4(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(
        arg1: *const std_locale,
        arg2: *const std_string,
        arg3: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale5(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(
        arg1: *const std_locale,
        arg2: *const std_locale,
        arg3: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale6(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_locale_locale_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale_facet {
    pub _base: std___shared_count,
}
#[test]
fn bindgen_test_layout_std_locale_facet() {
    assert_eq!(
        ::std::mem::size_of::<std_locale_facet>(),
        16usize,
        concat!("Size of: ", stringify!(std_locale_facet))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_facet>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale_facet))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16locale5facetD1Ev"]
    pub fn std_locale_facet_facet_destructor(this: *mut std_locale_facet);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_id {
    pub __flag_: std_once_flag,
    pub __id_: i32,
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16locale2id9__next_idE"]
    pub static mut std_locale_id___next_id: i32;
}
#[test]
fn bindgen_test_layout_std_locale_id() {
    assert_eq!(
        ::std::mem::size_of::<std_locale_id>(),
        16usize,
        concat!("Size of: ", stringify!(std_locale_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale_id))
    );
    fn test_field___flag_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_locale_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flag_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_locale_id),
                "::",
                stringify!(__flag_)
            )
        );
    }
    test_field___flag_();
    fn test_field___id_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_locale_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__id_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_locale_id),
                "::",
                stringify!(__id_)
            )
        );
    }
    test_field___id_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16locale2id5__getEv"]
    pub fn std_locale_id___get(this: *mut std_locale_id) -> ::std::os::raw::c_long;
}
impl std_locale_id {
    #[inline]
    pub unsafe fn __get(&mut self) -> ::std::os::raw::c_long {
        std_locale_id___get(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_collate {
    pub _base: std_locale_facet,
}
pub type std_collate_char_type<_CharT> = _CharT;
pub type std_collate_string_type = std_basic_string;
extern "C" {
    #[link_name = "\u{1}id"]
    pub static mut std_id: std_locale_id;
}
#[test]
fn __bindgen_test_layout_std_collate_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_collate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_collate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_collate_byname {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_collate_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_base {
    pub _address: u8,
}
pub type std_ctype_base_mask = __uint32_t;
pub const std_ctype_base_space: std_ctype_base_mask = 16384;
pub const std_ctype_base_print: std_ctype_base_mask = 262144;
pub const std_ctype_base_cntrl: std_ctype_base_mask = 512;
pub const std_ctype_base_upper: std_ctype_base_mask = 32768;
pub const std_ctype_base_lower: std_ctype_base_mask = 4096;
pub const std_ctype_base_alpha: std_ctype_base_mask = 256;
pub const std_ctype_base_digit: std_ctype_base_mask = 1024;
pub const std_ctype_base_punct: std_ctype_base_mask = 8192;
pub const std_ctype_base_xdigit: std_ctype_base_mask = 65536;
pub const std_ctype_base_blank: std_ctype_base_mask = 131072;
pub const std_ctype_base___regex_word: std_ctype_base_mask = 128;
pub const std_ctype_base_alnum: std_ctype_base_mask = 1280;
pub const std_ctype_base_graph: std_ctype_base_mask = 9472;
#[test]
fn bindgen_test_layout_std_ctype_base() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_base>(),
        1usize,
        concat!("Size of: ", stringify!(std_ctype_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std_ctype_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        32usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_byname {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_ctype_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_byname>(),
        40usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_base {
    pub _address: u8,
}
pub const std_codecvt_base_result_ok: std_codecvt_base_result = 0;
pub const std_codecvt_base_result_partial: std_codecvt_base_result = 1;
pub const std_codecvt_base_result_error: std_codecvt_base_result = 2;
pub const std_codecvt_base_result_noconv: std_codecvt_base_result = 3;
pub type std_codecvt_base_result = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_std_codecvt_base() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt_base>(),
        1usize,
        concat!("Size of: ", stringify!(std_codecvt_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std_codecvt_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_codecvt_open0_char_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_codecvt))
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_codecvt_open0_wchar_t_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_codecvt))
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_codecvt_open0_char16_t_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_codecvt))
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_codecvt_open0_char32_t_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_codecvt))
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_codecvt_byname {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_codecvt_byname_open0_char_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt_byname>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_codecvt_byname_open0_wchar_t_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_codecvt_byname_open0_char16_t_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt_byname>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_codecvt_byname_open0_char32_t_char___mbstate_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_codecvt_byname>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_codecvt_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_codecvt_byname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numpunct {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_numpunct_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct>(),
        48usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numpunct_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct>(),
        48usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numpunct_byname {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_numpunct_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct_byname>(),
        48usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numpunct_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct_byname>(),
        48usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct_byname)
        )
    );
}
pub type std_streamsize = isize;
#[repr(C)]
pub struct std_ios_base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base {
    pub vtable_: *const std_ios_base__bindgen_vtable,
    pub __fmtflags_: std_ios_base_fmtflags,
    pub __precision_: std_streamsize,
    pub __width_: std_streamsize,
    pub __rdstate_: std_ios_base_iostate,
    pub __exceptions_: std_ios_base_iostate,
    pub __rdbuf_: *mut ::std::os::raw::c_void,
    pub __loc_: *mut ::std::os::raw::c_void,
    pub __fn_: *mut std_ios_base_event_callback,
    pub __index_: *mut ::std::os::raw::c_int,
    pub __event_size_: size_t,
    pub __event_cap_: size_t,
    pub __iarray_: *mut ::std::os::raw::c_long,
    pub __iarray_size_: size_t,
    pub __iarray_cap_: size_t,
    pub __parray_: *mut *mut ::std::os::raw::c_void,
    pub __parray_size_: size_t,
    pub __parray_cap_: size_t,
}
pub type std_ios_base_fmtflags = ::std::os::raw::c_uint;
pub type std_ios_base_iostate = ::std::os::raw::c_uint;
pub type std_ios_base_openmode = ::std::os::raw::c_uint;
pub const std_ios_base_seekdir_beg: std_ios_base_seekdir = 0;
pub const std_ios_base_seekdir_cur: std_ios_base_seekdir = 1;
pub const std_ios_base_seekdir_end: std_ios_base_seekdir = 2;
pub type std_ios_base_seekdir = ::std::os::raw::c_uint;
pub type std_ios_base_io_state = std_ios_base_iostate;
pub type std_ios_base_open_mode = std_ios_base_openmode;
pub use self::std_ios_base_seekdir as std_ios_base_seek_dir;
pub type std_ios_base_streamoff = std_streamoff;
pub type std_ios_base_streampos = std_streampos;
pub const std_ios_base_event_erase_event: std_ios_base_event = 0;
pub const std_ios_base_event_imbue_event: std_ios_base_event = 1;
pub const std_ios_base_event_copyfmt_event: std_ios_base_event = 2;
pub type std_ios_base_event = ::std::os::raw::c_uint;
pub type std_ios_base_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: std_ios_base_event,
        arg2: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
    ),
>;
pub const std_ios_base_boolalpha: std_ios_base_fmtflags = 1;
pub const std_ios_base_dec: std_ios_base_fmtflags = 2;
pub const std_ios_base_fixed: std_ios_base_fmtflags = 4;
pub const std_ios_base_hex: std_ios_base_fmtflags = 8;
pub const std_ios_base_internal: std_ios_base_fmtflags = 16;
pub const std_ios_base_left: std_ios_base_fmtflags = 32;
pub const std_ios_base_oct: std_ios_base_fmtflags = 64;
pub const std_ios_base_right: std_ios_base_fmtflags = 128;
pub const std_ios_base_scientific: std_ios_base_fmtflags = 256;
pub const std_ios_base_showbase: std_ios_base_fmtflags = 512;
pub const std_ios_base_showpoint: std_ios_base_fmtflags = 1024;
pub const std_ios_base_showpos: std_ios_base_fmtflags = 2048;
pub const std_ios_base_skipws: std_ios_base_fmtflags = 4096;
pub const std_ios_base_unitbuf: std_ios_base_fmtflags = 8192;
pub const std_ios_base_uppercase: std_ios_base_fmtflags = 16384;
pub const std_ios_base_adjustfield: std_ios_base_fmtflags = 176;
pub const std_ios_base_basefield: std_ios_base_fmtflags = 74;
pub const std_ios_base_floatfield: std_ios_base_fmtflags = 260;
pub const std_ios_base_badbit: std_ios_base_iostate = 1;
pub const std_ios_base_eofbit: std_ios_base_iostate = 2;
pub const std_ios_base_failbit: std_ios_base_iostate = 4;
pub const std_ios_base_goodbit: std_ios_base_iostate = 0;
pub const std_ios_base_app: std_ios_base_openmode = 1;
pub const std_ios_base_ate: std_ios_base_openmode = 2;
pub const std_ios_base_binary: std_ios_base_openmode = 4;
pub const std_ios_base_in: std_ios_base_openmode = 8;
pub const std_ios_base_out: std_ios_base_openmode = 16;
pub const std_ios_base_trunc: std_ios_base_openmode = 32;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base9__xindex_E"]
    pub static mut std_ios_base___xindex_: std_atomic;
}
#[test]
fn bindgen_test_layout_std_ios_base() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base>(),
        136usize,
        concat!("Size of: ", stringify!(std_ios_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base))
    );
    fn test_field___fmtflags_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fmtflags_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__fmtflags_)
            )
        );
    }
    test_field___fmtflags_();
    fn test_field___precision_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__precision_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__precision_)
            )
        );
    }
    test_field___precision_();
    fn test_field___width_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__width_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__width_)
            )
        );
    }
    test_field___width_();
    fn test_field___rdstate_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rdstate_) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__rdstate_)
            )
        );
    }
    test_field___rdstate_();
    fn test_field___exceptions_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exceptions_) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__exceptions_)
            )
        );
    }
    test_field___exceptions_();
    fn test_field___rdbuf_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rdbuf_) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__rdbuf_)
            )
        );
    }
    test_field___rdbuf_();
    fn test_field___loc_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__loc_) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__loc_)
            )
        );
    }
    test_field___loc_();
    fn test_field___fn_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fn_) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__fn_)
            )
        );
    }
    test_field___fn_();
    fn test_field___index_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__index_) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__index_)
            )
        );
    }
    test_field___index_();
    fn test_field___event_size_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__event_size_) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__event_size_)
            )
        );
    }
    test_field___event_size_();
    fn test_field___event_cap_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__event_cap_) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__event_cap_)
            )
        );
    }
    test_field___event_cap_();
    fn test_field___iarray_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__iarray_) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__iarray_)
            )
        );
    }
    test_field___iarray_();
    fn test_field___iarray_size_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__iarray_size_) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__iarray_size_)
            )
        );
    }
    test_field___iarray_size_();
    fn test_field___iarray_cap_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__iarray_cap_) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__iarray_cap_)
            )
        );
    }
    test_field___iarray_cap_();
    fn test_field___parray_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__parray_) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__parray_)
            )
        );
    }
    test_field___parray_();
    fn test_field___parray_size_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__parray_size_) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__parray_size_)
            )
        );
    }
    test_field___parray_size_();
    fn test_field___parray_cap_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_ios_base>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__parray_cap_) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(std_ios_base),
                "::",
                stringify!(__parray_cap_)
            )
        );
    }
    test_field___parray_cap_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base5imbueERKNS_6localeE"]
    pub fn std_ios_base_imbue(this: *mut std_ios_base, __loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__18ios_base6getlocEv"]
    pub fn std_ios_base_getloc(this: *const std_ios_base) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base6xallocEv"]
    pub fn std_ios_base_xalloc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base5iwordEi"]
    pub fn std_ios_base_iword(
        this: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base5pwordEi"]
    pub fn std_ios_base_pword(
        this: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base17register_callbackEPFvNS0_5eventERS0_iEi"]
    pub fn std_ios_base_register_callback(
        this: *mut std_ios_base,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base15sync_with_stdioEb"]
    pub fn std_ios_base_sync_with_stdio(__sync: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base5clearEj"]
    pub fn std_ios_base_clear(this: *mut std_ios_base, __state: std_ios_base_iostate);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base33__set_badbit_and_consider_rethrowEv"]
    pub fn std_ios_base___set_badbit_and_consider_rethrow(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base34__set_failbit_and_consider_rethrowEv"]
    pub fn std_ios_base___set_failbit_and_consider_rethrow(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base4initEPv"]
    pub fn std_ios_base_init(this: *mut std_ios_base, __sb: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base16__call_callbacksENS0_5eventE"]
    pub fn std_ios_base___call_callbacks(this: *mut std_ios_base, arg1: std_ios_base_event);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base7copyfmtERKS0_"]
    pub fn std_ios_base_copyfmt(this: *mut std_ios_base, arg1: *const std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base4moveERS0_"]
    pub fn std_ios_base_move(this: *mut std_ios_base, arg1: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base4swapERS0_"]
    pub fn std_ios_base_swap(this: *mut std_ios_base, arg1: *mut std_ios_base);
}
impl std_ios_base {
    #[inline]
    pub unsafe fn imbue(&mut self, __loc: *const std_locale) -> std_locale {
        std_ios_base_imbue(self, __loc)
    }
    #[inline]
    pub unsafe fn getloc(&self) -> std_locale {
        std_ios_base_getloc(self)
    }
    #[inline]
    pub unsafe fn xalloc() -> ::std::os::raw::c_int {
        std_ios_base_xalloc()
    }
    #[inline]
    pub unsafe fn iword(&mut self, __index: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_long {
        std_ios_base_iword(self, __index)
    }
    #[inline]
    pub unsafe fn pword(
        &mut self,
        __index: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_void {
        std_ios_base_pword(self, __index)
    }
    #[inline]
    pub unsafe fn register_callback(
        &mut self,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    ) {
        std_ios_base_register_callback(self, __fn, __index)
    }
    #[inline]
    pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
        std_ios_base_sync_with_stdio(__sync)
    }
    #[inline]
    pub unsafe fn clear(&mut self, __state: std_ios_base_iostate) {
        std_ios_base_clear(self, __state)
    }
    #[inline]
    pub unsafe fn __set_badbit_and_consider_rethrow(&mut self) {
        std_ios_base___set_badbit_and_consider_rethrow(self)
    }
    #[inline]
    pub unsafe fn __set_failbit_and_consider_rethrow(&mut self) {
        std_ios_base___set_failbit_and_consider_rethrow(self)
    }
    #[inline]
    pub unsafe fn init(&mut self, __sb: *mut ::std::os::raw::c_void) {
        std_ios_base_init(self, __sb)
    }
    #[inline]
    pub unsafe fn __call_callbacks(&mut self, arg1: std_ios_base_event) {
        std_ios_base___call_callbacks(self, arg1)
    }
    #[inline]
    pub unsafe fn copyfmt(&mut self, arg1: *const std_ios_base) {
        std_ios_base_copyfmt(self, arg1)
    }
    #[inline]
    pub unsafe fn move_(&mut self, arg1: *mut std_ios_base) {
        std_ios_base_move(self, arg1)
    }
    #[inline]
    pub unsafe fn swap(&mut self, arg1: *mut std_ios_base) {
        std_ios_base_swap(self, arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_baseD1Ev"]
    pub fn std_ios_base_ios_base_destructor(this: *mut std_ios_base);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_io_errc {
    pub __v_: std_io_errc___lx,
}
pub const std_io_errc___lx_stream: std_io_errc___lx = 1;
pub type std_io_errc___lx = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_std_io_errc() {
    assert_eq!(
        ::std::mem::size_of::<std_io_errc>(),
        4usize,
        concat!("Size of: ", stringify!(std_io_errc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_io_errc>(),
        4usize,
        concat!("Alignment of ", stringify!(std_io_errc))
    );
    fn test_field___v_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_io_errc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_io_errc),
                "::",
                stringify!(__v_)
            )
        );
    }
    test_field___v_();
}
#[test]
fn __bindgen_test_layout_std_is_error_code_enum_open0_std_io_errc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_error_code_enum_open0_std_io_errc___lx_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__117iostream_categoryEv"]
    pub fn std_iostream_category() -> *const std_error_category;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_failure {
    pub _base: std_system_error,
}
#[test]
fn bindgen_test_layout_std_ios_base_failure() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_failure>(),
        32usize,
        concat!("Size of: ", stringify!(std_ios_base_failure))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_failure>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base_failure))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base7failureC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_10error_codeE"]
    pub fn std_ios_base_failure_failure(
        this: *mut std_ios_base_failure,
        __msg: *const std_string,
        __ec: *const std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base7failureC1EPKcRKNS_10error_codeE"]
    pub fn std_ios_base_failure_failure1(
        this: *mut std_ios_base_failure,
        __msg: *const ::std::os::raw::c_char,
        __ec: *const std_error_code,
    );
}
impl std_ios_base_failure {
    #[inline]
    pub unsafe fn new(__msg: *const std_string, __ec: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure(__bindgen_tmp.as_mut_ptr(), __msg, __ec);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__msg: *const ::std::os::raw::c_char, __ec: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure1(__bindgen_tmp.as_mut_ptr(), __msg, __ec);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base7failureD1Ev"]
    pub fn std_ios_base_failure_failure_destructor(this: *mut std_ios_base_failure);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_Init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_ios_base_Init() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_Init>(),
        1usize,
        concat!("Size of: ", stringify!(std_ios_base_Init))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_Init>(),
        1usize,
        concat!("Alignment of ", stringify!(std_ios_base_Init))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base4InitC1Ev"]
    pub fn std_ios_base_Init_Init(this: *mut std_ios_base_Init);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18ios_base4InitD1Ev"]
    pub fn std_ios_base_Init_Init_destructor(this: *mut std_ios_base_Init);
}
impl std_ios_base_Init {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_Init_Init(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_ios_base_Init_Init_destructor(self)
    }
}
#[repr(C)]
pub struct std_basic_ios {
    pub _base: std_ios_base,
    pub __tie_: *mut std_basic_ostream,
    pub __fill_: std_basic_ios_int_type,
}
pub type std_basic_ios_char_type<_CharT> = _CharT;
pub type std_basic_ios_traits_type<_Traits> = _Traits;
pub type std_basic_ios_int_type = [u8; 0usize];
pub type std_basic_ios_pos_type = [u8; 0usize];
pub type std_basic_ios_off_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_storage_type {
    pub _address: u8,
}
pub type std___bit_reference___storage_type = [u8; 0usize];
pub type std___bit_reference___storage_pointer = [u8; 0usize];
#[repr(C)]
pub struct std___bit_const_reference {
    pub __seg_: std___bit_const_reference___storage_pointer,
    pub __mask_: std___bit_const_reference___storage_type,
}
pub type std___bit_const_reference___storage_type = [u8; 0usize];
pub type std___bit_const_reference___storage_pointer = [u8; 0usize];
#[repr(C)]
pub struct std___bit_array {
    pub __size_: std___bit_array_difference_type,
    pub __word_: *mut std___bit_array___storage_type,
}
pub type std___bit_array_difference_type = [u8; 0usize];
pub type std___bit_array___storage_type = [u8; 0usize];
pub type std___bit_array___storage_pointer = [u8; 0usize];
pub type std___bit_array_iterator = [u8; 0usize];
pub type std___bit_iterator_difference_type = [u8; 0usize];
pub type std___bit_iterator_value_type = bool;
pub type std___bit_iterator_pointer = u8;
pub type std___bit_iterator_reference = u8;
pub type std___bit_iterator_iterator_category = std_random_access_iterator_tag;
pub type std___bit_iterator___storage_type = [u8; 0usize];
pub type std___bit_iterator___storage_pointer = [u8; 0usize];
pub type std___bitset_difference_type = isize;
pub type std___bitset_size_type = size_t;
pub type std___bitset___storage_type = std___bitset_size_type;
pub type std___bitset___self = u8;
pub type std___bitset___storage_pointer = *mut std___bitset___storage_type;
pub type std___bitset___const_storage_pointer = *const std___bitset___storage_type;
pub const std___bitset___bits_per_word: ::std::os::raw::c_uint = 64;
pub type std___bitset_reference = u8;
pub type std___bitset_const_reference = std___bit_const_reference;
pub type std___bitset_iterator = u8;
pub type std___bitset_const_iterator = u8;
extern "C" {
    #[link_name = "\u{1}flip"]
    pub fn std___bitset_flip(this: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}all"]
    pub fn std___bitset_all(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}any"]
    pub fn std___bitset_any(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__n_words"]
    pub static std_bitset___n_words: ::std::os::raw::c_uint;
}
pub type std_bitset_base = u8;
pub type std_bitset_reference = std_bitset_base;
pub type std_bitset_const_reference = std_bitset_base;
extern "C" {
    #[link_name = "\u{1}set"]
    pub fn std_bitset_set1(this: *mut u8, __pos: size_t, __val: bool) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}reset"]
    pub fn std_bitset_reset1(this: *mut u8, __pos: size_t) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}flip"]
    pub fn std_bitset_flip1(this: *mut u8, __pos: size_t) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}test"]
    pub fn std_bitset_test(this: *const u8, __pos: size_t) -> bool;
}
#[repr(C)]
pub struct std_basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_streambuf<_CharT> {
    pub vtable_: *const std_basic_streambuf__bindgen_vtable,
    pub __loc_: std_locale,
    pub __binp_: *mut std_basic_streambuf_char_type<_CharT>,
    pub __ninp_: *mut std_basic_streambuf_char_type<_CharT>,
    pub __einp_: *mut std_basic_streambuf_char_type<_CharT>,
    pub __bout_: *mut std_basic_streambuf_char_type<_CharT>,
    pub __nout_: *mut std_basic_streambuf_char_type<_CharT>,
    pub __eout_: *mut std_basic_streambuf_char_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_streambuf_char_type<_CharT> = _CharT;
pub type std_basic_streambuf_traits_type<_Traits> = _Traits;
pub type std_basic_streambuf_int_type = [u8; 0usize];
pub type std_basic_streambuf_pos_type = [u8; 0usize];
pub type std_basic_streambuf_off_type = [u8; 0usize];
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios>(),
        152usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios>(),
        152usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___num_get_base {
    pub _address: u8,
}
pub const std___num_get_base___num_get_buf_sz: ::std::os::raw::c_int = 40;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__num_get_base5__srcE"]
    pub static std___num_get_base___src: [::std::os::raw::c_char; 33usize];
}
#[test]
fn bindgen_test_layout_std___num_get_base() {
    assert_eq!(
        ::std::mem::size_of::<std___num_get_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___num_get_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_get_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___num_get_base))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__num_get_base10__get_baseERNS_8ios_baseE"]
    pub fn std___num_get_base___get_base(arg1: *mut std_ios_base) -> ::std::os::raw::c_int;
}
impl std___num_get_base {
    #[inline]
    pub unsafe fn __get_base(arg1: *mut std_ios_base) -> ::std::os::raw::c_int {
        std___num_get_base___get_base(arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__116__check_groupingERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjS8_Rj"]
    pub fn std___check_grouping(
        __grouping: *const std_string,
        __g: *mut ::std::os::raw::c_uint,
        __g_end: *mut ::std::os::raw::c_uint,
        __err: *mut std_ios_base_iostate,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___num_get {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___num_get_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___num_get>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___num_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_get>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___num_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___num_get_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___num_get>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___num_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_get>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___num_get)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_num_get {
    pub _base: std_locale_facet,
}
pub type std_num_get_char_type<_CharT> = _CharT;
pub type std_num_get_iter_type<_InputIterator> = _InputIterator;
#[test]
fn __bindgen_test_layout_std_num_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_get>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_get))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_num_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_get>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_get))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_get)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___num_put_base {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___num_put_base() {
    assert_eq!(
        ::std::mem::size_of::<std___num_put_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___num_put_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_put_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___num_put_base))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__num_put_base12__format_intEPcPKcbj"]
    pub fn std___num_put_base___format_int(
        __fmt: *mut ::std::os::raw::c_char,
        __len: *const ::std::os::raw::c_char,
        __signd: bool,
        __flags: std_ios_base_fmtflags,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__num_put_base14__format_floatEPcPKcj"]
    pub fn std___num_put_base___format_float(
        __fmt: *mut ::std::os::raw::c_char,
        __len: *const ::std::os::raw::c_char,
        __flags: std_ios_base_fmtflags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__num_put_base18__identify_paddingEPcS1_RKNS_8ios_baseE"]
    pub fn std___num_put_base___identify_padding(
        __nb: *mut ::std::os::raw::c_char,
        __ne: *mut ::std::os::raw::c_char,
        __iob: *const std_ios_base,
    ) -> *mut ::std::os::raw::c_char;
}
impl std___num_put_base {
    #[inline]
    pub unsafe fn __format_int(
        __fmt: *mut ::std::os::raw::c_char,
        __len: *const ::std::os::raw::c_char,
        __signd: bool,
        __flags: std_ios_base_fmtflags,
    ) {
        std___num_put_base___format_int(__fmt, __len, __signd, __flags)
    }
    #[inline]
    pub unsafe fn __format_float(
        __fmt: *mut ::std::os::raw::c_char,
        __len: *const ::std::os::raw::c_char,
        __flags: std_ios_base_fmtflags,
    ) -> bool {
        std___num_put_base___format_float(__fmt, __len, __flags)
    }
    #[inline]
    pub unsafe fn __identify_padding(
        __nb: *mut ::std::os::raw::c_char,
        __ne: *mut ::std::os::raw::c_char,
        __iob: *const std_ios_base,
    ) -> *mut ::std::os::raw::c_char {
        std___num_put_base___identify_padding(__nb, __ne, __iob)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___num_put {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___num_put_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___num_put>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___num_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_put>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___num_put)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___num_put_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___num_put>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___num_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_put>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___num_put)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_num_put {
    pub _base: std_locale_facet,
}
pub type std_num_put_char_type<_CharT> = _CharT;
pub type std_num_put_iter_type<_OutputIterator> = _OutputIterator;
#[test]
fn __bindgen_test_layout_std_num_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_put>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_put))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_put)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_num_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_put>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_put))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_put)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_base {
    pub _address: u8,
}
pub const std_time_base_dateorder_no_order: std_time_base_dateorder = 0;
pub const std_time_base_dateorder_dmy: std_time_base_dateorder = 1;
pub const std_time_base_dateorder_mdy: std_time_base_dateorder = 2;
pub const std_time_base_dateorder_ymd: std_time_base_dateorder = 3;
pub const std_time_base_dateorder_ydm: std_time_base_dateorder = 4;
pub type std_time_base_dateorder = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_std_time_base() {
    assert_eq!(
        ::std::mem::size_of::<std_time_base>(),
        1usize,
        concat!("Size of: ", stringify!(std_time_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std_time_base))
    );
}
#[repr(C)]
pub struct std___time_get_c_storage__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std___time_get_c_storage {
    pub vtable_: *const std___time_get_c_storage__bindgen_vtable,
}
pub type std___time_get_c_storage_string_type = std_basic_string;
#[repr(C)]
#[derive(Debug)]
pub struct std_time_get {
    pub _base: std_locale_facet,
    pub _base_2: std___time_get_c_storage,
}
pub type std_time_get_char_type<_CharT> = _CharT;
pub type std_time_get_iter_type<_InputIterator> = _InputIterator;
pub use self::std_time_base_dateorder as std_time_get_dateorder;
pub type std_time_get_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std_time_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_get>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_time_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_get>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_get)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___time_get {
    pub __loc_: locale_t,
}
#[test]
fn bindgen_test_layout_std___time_get() {
    assert_eq!(
        ::std::mem::size_of::<std___time_get>(),
        8usize,
        concat!("Size of: ", stringify!(std___time_get))
    );
    assert_eq!(
        ::std::mem::align_of::<std___time_get>(),
        8usize,
        concat!("Alignment of ", stringify!(std___time_get))
    );
    fn test_field___loc_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___time_get>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__loc_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___time_get),
                "::",
                stringify!(__loc_)
            )
        );
    }
    test_field___loc_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110__time_getC1EPKc"]
    pub fn std___time_get___time_get(
        this: *mut std___time_get,
        __nm: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110__time_getC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"]
    pub fn std___time_get___time_get1(this: *mut std___time_get, __nm: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110__time_getD1Ev"]
    pub fn std___time_get___time_get_destructor(this: *mut std___time_get);
}
impl std___time_get {
    #[inline]
    pub unsafe fn new(__nm: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___time_get___time_get(__bindgen_tmp.as_mut_ptr(), __nm);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__nm: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___time_get___time_get1(__bindgen_tmp.as_mut_ptr(), __nm);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___time_get___time_get_destructor(self)
    }
}
#[repr(C)]
pub struct std___time_get_storage {
    pub _base: std___time_get,
    pub __weeks_: [std___time_get_storage_string_type; 14usize],
    pub __months_: [std___time_get_storage_string_type; 24usize],
    pub __am_pm_: [std___time_get_storage_string_type; 2usize],
    pub __c_: std___time_get_storage_string_type,
    pub __r_: std___time_get_storage_string_type,
    pub __x_: std___time_get_storage_string_type,
    pub __X_: std___time_get_storage_string_type,
}
pub type std___time_get_storage_string_type = std_basic_string;
#[repr(C)]
pub struct std_time_get_byname {
    pub _base: std_time_get,
    pub _base_1: std___time_get_storage,
}
pub use self::std_time_base_dateorder as std_time_get_byname_dateorder;
pub type std_time_get_byname_iter_type<_InputIterator> = _InputIterator;
pub type std_time_get_byname_char_type<_CharT> = _CharT;
pub type std_time_get_byname_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std_time_get_byname_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_get_byname>(),
        1088usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_get_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_get_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_get_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_time_get_byname_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_get_byname>(),
        1088usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_get_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_get_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_get_byname)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___time_put {
    pub __loc_: locale_t,
}
#[test]
fn bindgen_test_layout_std___time_put() {
    assert_eq!(
        ::std::mem::size_of::<std___time_put>(),
        8usize,
        concat!("Size of: ", stringify!(std___time_put))
    );
    assert_eq!(
        ::std::mem::align_of::<std___time_put>(),
        8usize,
        concat!("Alignment of ", stringify!(std___time_put))
    );
    fn test_field___loc_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std___time_put>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__loc_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std___time_put),
                "::",
                stringify!(__loc_)
            )
        );
    }
    test_field___loc_();
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__110__time_put8__do_putEPcRS1_PK2tmcc"]
    pub fn std___time_put___do_put(
        this: *const std___time_put,
        __nb: *mut ::std::os::raw::c_char,
        __ne: *mut *mut ::std::os::raw::c_char,
        __tm: *const tm,
        __fmt: ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__110__time_put8__do_putEPwRS1_PK2tmcc"]
    pub fn std___time_put___do_put1(
        this: *const std___time_put,
        __wb: *mut u32,
        __we: *mut *mut u32,
        __tm: *const tm,
        __fmt: ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110__time_putC1EPKc"]
    pub fn std___time_put___time_put(
        this: *mut std___time_put,
        __nm: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110__time_putC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"]
    pub fn std___time_put___time_put1(this: *mut std___time_put, __nm: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__110__time_putD1Ev"]
    pub fn std___time_put___time_put_destructor(this: *mut std___time_put);
}
impl std___time_put {
    #[inline]
    pub unsafe fn __do_put(
        &self,
        __nb: *mut ::std::os::raw::c_char,
        __ne: *mut *mut ::std::os::raw::c_char,
        __tm: *const tm,
        __fmt: ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    ) {
        std___time_put___do_put(self, __nb, __ne, __tm, __fmt, __mod)
    }
    #[inline]
    pub unsafe fn __do_put1(
        &self,
        __wb: *mut u32,
        __we: *mut *mut u32,
        __tm: *const tm,
        __fmt: ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    ) {
        std___time_put___do_put1(self, __wb, __we, __tm, __fmt, __mod)
    }
    #[inline]
    pub unsafe fn new(__nm: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___time_put___time_put(__bindgen_tmp.as_mut_ptr(), __nm);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__nm: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___time_put___time_put1(__bindgen_tmp.as_mut_ptr(), __nm);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___time_put___time_put_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_time_put {
    pub _base: std_locale_facet,
    pub _base_1: std___time_put,
}
pub type std_time_put_char_type<_CharT> = _CharT;
pub type std_time_put_iter_type<_OutputIterator> = _OutputIterator;
#[test]
fn __bindgen_test_layout_std_time_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_put>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_put)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_time_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_put>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_put)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_time_put_byname {
    pub _base: std_time_put,
}
#[test]
fn __bindgen_test_layout_std_time_put_byname_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_put_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_put_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_put_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_put_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_time_put_byname_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_time_put_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_time_put_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_time_put_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_time_put_byname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base {
    pub _address: u8,
}
pub const std_money_base_part_none: std_money_base_part = 0;
pub const std_money_base_part_space: std_money_base_part = 1;
pub const std_money_base_part_symbol: std_money_base_part = 2;
pub const std_money_base_part_sign: std_money_base_part = 3;
pub const std_money_base_part_value: std_money_base_part = 4;
pub type std_money_base_part = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base_pattern {
    pub field: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_std_money_base_pattern() {
    assert_eq!(
        ::std::mem::size_of::<std_money_base_pattern>(),
        4usize,
        concat!("Size of: ", stringify!(std_money_base_pattern))
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_base_pattern>(),
        1usize,
        concat!("Alignment of ", stringify!(std_money_base_pattern))
    );
    fn test_field_field() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_money_base_pattern>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_money_base_pattern),
                "::",
                stringify!(field)
            )
        );
    }
    test_field_field();
}
#[test]
fn bindgen_test_layout_std_money_base() {
    assert_eq!(
        ::std::mem::size_of::<std_money_base>(),
        1usize,
        concat!("Size of: ", stringify!(std_money_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std_money_base))
    );
}
pub type std_moneypunct_char_type<_CharT> = _CharT;
pub type std_moneypunct_string_type = std_basic_string;
extern "C" {
    #[link_name = "\u{1}intl"]
    pub static std_intl: bool;
}
pub type std_moneypunct_byname_pattern = std_money_base_pattern;
pub type std_moneypunct_byname_char_type<_CharT> = _CharT;
pub type std_moneypunct_byname_string_type = std_basic_string;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___money_get {
    pub _address: u8,
}
pub type std___money_get_char_type<_CharT> = _CharT;
pub type std___money_get_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std___money_get_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___money_get>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___money_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___money_get>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___money_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___money_get_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___money_get>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___money_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___money_get>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___money_get)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_money_get {
    pub _base: std_locale_facet,
}
pub type std_money_get_char_type<_CharT> = _CharT;
pub type std_money_get_iter_type<_InputIterator> = _InputIterator;
pub type std_money_get_string_type = std_basic_string;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__do_nothingEPv"]
    pub fn std___do_nothing(arg1: *mut ::std::os::raw::c_void);
}
#[test]
fn __bindgen_test_layout_std_money_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_money_get>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_money_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_money_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_money_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_money_get>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_money_get)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_money_get)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___money_put {
    pub _address: u8,
}
pub type std___money_put_char_type<_CharT> = _CharT;
pub type std___money_put_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std___money_put_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___money_put>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___money_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___money_put>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___money_put)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___money_put_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___money_put>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___money_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___money_put>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___money_put)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_money_put {
    pub _base: std_locale_facet,
}
pub type std_money_put_char_type<_CharT> = _CharT;
pub type std_money_put_iter_type<_OutputIterator> = _OutputIterator;
pub type std_money_put_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std_money_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_money_put>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_money_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_money_put)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_money_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_money_put>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_money_put)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_money_put)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_base {
    pub _address: u8,
}
pub type std_messages_base_catalog = isize;
#[test]
fn bindgen_test_layout_std_messages_base() {
    assert_eq!(
        ::std::mem::size_of::<std_messages_base>(),
        1usize,
        concat!("Size of: ", stringify!(std_messages_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_messages_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std_messages_base))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_messages {
    pub _base: std_locale_facet,
}
pub type std_messages_char_type<_CharT> = _CharT;
pub type std_messages_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std_messages_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_messages>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_messages)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_messages>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_messages)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_messages_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_messages>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_messages)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_messages>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_messages)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_messages_byname {
    pub _base: std_messages,
}
pub type std_messages_byname_catalog = std_messages_base_catalog;
pub type std_messages_byname_string_type = std_basic_string;
#[test]
fn __bindgen_test_layout_std_messages_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_messages_byname>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_messages_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_messages_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_messages_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_messages_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_messages_byname>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_messages_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_messages_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_messages_byname)
        )
    );
}
#[repr(C)]
pub struct std_wstring_convert<_Codecvt> {
    pub __byte_err_string_: std_wstring_convert_byte_string,
    pub __wide_err_string_: std_wstring_convert_wide_string,
    pub __cvtptr_: *mut _Codecvt,
    pub __cvtstate_: std_wstring_convert_state_type,
    pub __cvtcount_: size_t,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Codecvt>>,
}
pub type std_wstring_convert_byte_string = std_basic_string;
pub type std_wstring_convert_wide_string = std_basic_string;
pub type std_wstring_convert_state_type = [u8; 0usize];
pub type std_wstring_convert_int_type = std_wstring_convert_wide_string;
#[repr(C)]
pub struct std_wbuffer_convert<_Codecvt, _Elem> {
    pub _base: std_basic_streambuf<_Elem>,
    pub __extbuf_: *mut ::std::os::raw::c_char,
    pub __extbufnext_: *const ::std::os::raw::c_char,
    pub __extbufend_: *const ::std::os::raw::c_char,
    pub __extbuf_min_: [::std::os::raw::c_char; 8usize],
    pub __ebs_: size_t,
    pub __intbuf_: *mut std_wbuffer_convert_char_type<_Elem>,
    pub __ibs_: size_t,
    pub __bufptr_: *mut std_streambuf,
    pub __cv_: *mut _Codecvt,
    pub __st_: std_wbuffer_convert_state_type,
    pub __cm_: std_ios_base_openmode,
    pub __owns_eb_: bool,
    pub __owns_ib_: bool,
    pub __always_noconv_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Codecvt>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Elem>>,
}
pub type std_wbuffer_convert_char_type<_Elem> = _Elem;
pub type std_wbuffer_convert_traits_type<_Tr> = _Tr;
pub type std_wbuffer_convert_int_type = [u8; 0usize];
pub type std_wbuffer_convert_pos_type = [u8; 0usize];
pub type std_wbuffer_convert_off_type = [u8; 0usize];
pub type std_wbuffer_convert_state_type = [u8; 0usize];
#[repr(C)]
pub struct std_basic_ostream {}
pub type std_basic_ostream_char_type<_CharT> = _CharT;
pub type std_basic_ostream_traits_type<_Traits> = _Traits;
pub type std_basic_ostream_int_type = [u8; 0usize];
pub type std_basic_ostream_pos_type = [u8; 0usize];
pub type std_basic_ostream_off_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream_sentry {
    pub __ok_: bool,
    pub __os_: *mut std_basic_ostream,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_ostreamable {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
}
#[repr(C)]
pub struct std_basic_istream {
    pub __gc_: std_streamsize,
}
pub type std_basic_istream_char_type<_CharT> = _CharT;
pub type std_basic_istream_traits_type<_Traits> = _Traits;
pub type std_basic_istream_int_type = [u8; 0usize];
pub type std_basic_istream_pos_type = [u8; 0usize];
pub type std_basic_istream_off_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub __ok_: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_istreamable {
    pub _base: std_false_type,
}
#[repr(C)]
pub struct std_basic_iostream {
    pub _base: std_basic_istream,
    pub _base_1: std_basic_ostream,
}
pub type std_basic_iostream_char_type<_CharT> = _CharT;
pub type std_basic_iostream_traits_type<_Traits> = _Traits;
pub type std_basic_iostream_int_type = [u8; 0usize];
pub type std_basic_iostream_pos_type = [u8; 0usize];
pub type std_basic_iostream_off_type = [u8; 0usize];
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream>(),
        168usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream>(),
        168usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_iostream>(),
        176usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_iostream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_iostream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_iostream)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__13cinE"]
    pub static mut std_cin: std_istream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14wcinE"]
    pub static mut std_wcin: std_wistream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14coutE"]
    pub static mut std_cout: std_ostream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15wcoutE"]
    pub static mut std_wcout: std_wostream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14cerrE"]
    pub static mut std_cerr: std_ostream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15wcerrE"]
    pub static mut std_wcerr: std_wostream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__14clogE"]
    pub static mut std_clog: std_ostream;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15wclogE"]
    pub static mut std_wclog: std_wostream;
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13bad_exceptionD1Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_unexpected_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt14get_unexpectedv"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt10unexpectedv"]
    pub fn std_unexpected();
}
pub type std_terminate_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt13get_terminatev"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt9terminatev"]
    pub fn std_terminate();
}
extern "C" {
    #[link_name = "\u{1}__ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZSt19uncaught_exceptionsv"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZSt17current_exceptionv"]
    pub fn std_current_exception() -> std_exception_ptr;
}
extern "C" {
    #[link_name = "\u{1}__ZSt17rethrow_exceptionSt13exception_ptr"]
    pub fn std_rethrow_exception(arg1: std_exception_ptr);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_exception_ptr {
    pub __ptr_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_std_exception_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_exception_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception_ptr))
    );
    fn test_field___ptr_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_exception_ptr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ptr_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(std_exception_ptr),
                "::",
                stringify!(__ptr_)
            )
        );
    }
    test_field___ptr_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13exception_ptrC1ERKS_"]
    pub fn std_exception_ptr_exception_ptr(
        this: *mut std_exception_ptr,
        arg1: *const std_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13exception_ptrD1Ev"]
    pub fn std_exception_ptr_exception_ptr_destructor(this: *mut std_exception_ptr);
}
impl std_exception_ptr {
    #[inline]
    pub unsafe fn new(arg1: *const std_exception_ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_exception_ptr_exception_ptr(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_exception_ptr_exception_ptr_destructor(self)
    }
}
#[repr(C)]
pub struct std_nested_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_nested_exception {
    pub vtable_: *const std_nested_exception__bindgen_vtable,
    pub __ptr_: std_exception_ptr,
}
#[test]
fn bindgen_test_layout_std_nested_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_nested_exception>(),
        16usize,
        concat!("Size of: ", stringify!(std_nested_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nested_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_nested_exception))
    );
    fn test_field___ptr_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_nested_exception>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ptr_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_nested_exception),
                "::",
                stringify!(__ptr_)
            )
        );
    }
    test_field___ptr_();
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt16nested_exception14rethrow_nestedEv"]
    pub fn std_nested_exception_rethrow_nested(this: *const std_nested_exception);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt16nested_exceptionC1Ev"]
    pub fn std_nested_exception_nested_exception(this: *mut std_nested_exception);
}
impl std_nested_exception {
    #[inline]
    pub unsafe fn rethrow_nested(&self) {
        std_nested_exception_rethrow_nested(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_nested_exception_nested_exception(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt16nested_exceptionD1Ev"]
    pub fn std_nested_exception_nested_exception_destructor(this: *mut std_nested_exception);
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nested<_Tp> {
    pub _base: _Tp,
    pub _base_1: std_nested_exception,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_dynamic_cast {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nothrow_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nothrow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nothrow_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nothrow_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_alloc>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_alloc>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_alloc))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9bad_allocC1Ev"]
    pub fn std_bad_alloc_bad_alloc(this: *mut std_bad_alloc);
}
impl std_bad_alloc {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_alloc_bad_alloc(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
#[test]
fn bindgen_test_layout_std_bad_array_new_length() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_array_new_length))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_array_new_length))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt20bad_array_new_lengthC1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length(this: *mut std_bad_array_new_length);
}
impl std_bad_array_new_length {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_array_new_length_bad_array_new_length(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc();
}
pub const std_align_val_t___zero: std_align_val_t = 0;
pub const std_align_val_t___max: std_align_val_t = 18446744073709551615;
pub type std_align_val_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___string_impl_base {
    pub _address: u8,
}
pub type std___type_info_implementations___string_impl_base___type_name_t =
    *const ::std::os::raw::c_char;
#[test]
fn bindgen_test_layout_std___type_info_implementations___string_impl_base() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___string_impl_base>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___string_impl_base)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___string_impl_base>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___string_impl_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___unique_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___type_info_implementations___unique_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___unique_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___unique_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___unique_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___unique_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___non_unique_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___type_info_implementations___non_unique_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___non_unique_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___non_unique_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___non_unique_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___non_unique_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___non_unique_arm_rtti_bit_impl {
    pub _address: u8,
}
pub type std___type_info_implementations___non_unique_arm_rtti_bit_impl___type_name_t = usize;
pub type std___type_info_implementations___non_unique_arm_rtti_bit_impl___non_unique_rtti_bit = u8;
#[test]
fn bindgen_test_layout_std___type_info_implementations___non_unique_arm_rtti_bit_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___non_unique_arm_rtti_bit_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___non_unique_arm_rtti_bit_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___non_unique_arm_rtti_bit_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___non_unique_arm_rtti_bit_impl)
        )
    );
}
pub type std___type_info_implementations___impl =
    std___type_info_implementations___non_unique_arm_rtti_bit_impl;
#[test]
fn bindgen_test_layout_std___type_info_implementations() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations>(),
        1usize,
        concat!("Size of: ", stringify!(std___type_info_implementations))
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations>(),
        1usize,
        concat!("Alignment of ", stringify!(std___type_info_implementations))
    );
}
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __type_name: std___type_info_implementations___non_unique_arm_rtti_bit_impl___type_name_t,
}
pub type std_type_info___impl = std___type_info_implementations___impl;
#[test]
fn bindgen_test_layout_std_type_info() {
    assert_eq!(
        ::std::mem::size_of::<std_type_info>(),
        16usize,
        concat!("Size of: ", stringify!(std_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std_type_info))
    );
    fn test_field___type_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_type_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__type_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_type_info),
                "::",
                stringify!(__type_name)
            )
        );
    }
    test_field___type_name();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_cast {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_cast() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_cast>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_cast))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_cast>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_cast))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt8bad_castC1Ev"]
    pub fn std_bad_cast_bad_cast(this: *mut std_bad_cast);
}
impl std_bad_cast {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_cast_bad_cast(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt8bad_castD1Ev"]
    pub fn std_bad_cast_bad_cast_destructor(this: *mut std_bad_cast);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt8bad_cast4whatEv"]
    pub fn std_bad_cast_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_typeid {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_typeid() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_typeid>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_typeid))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_typeid>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_typeid))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt10bad_typeidC1Ev"]
    pub fn std_bad_typeid_bad_typeid(this: *mut std_bad_typeid);
}
impl std_bad_typeid {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_typeid_bad_typeid(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt10bad_typeidD1Ev"]
    pub fn std_bad_typeid_bad_typeid_destructor(this: *mut std_bad_typeid);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt10bad_typeid4whatEv"]
    pub fn std_bad_typeid_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_logic_error {
    pub _base: std_exception,
    pub __imp_: std___libcpp_refstring,
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    assert_eq!(
        ::std::mem::size_of::<std_logic_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_logic_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_logic_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_logic_error))
    );
    fn test_field___imp_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_logic_error>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__imp_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_logic_error),
                "::",
                stringify!(__imp_)
            )
        );
    }
    test_field___imp_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorC1ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_runtime_error {
    pub _base: std_exception,
    pub __imp_: std___libcpp_refstring,
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    assert_eq!(
        ::std::mem::size_of::<std_runtime_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_runtime_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_runtime_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_runtime_error))
    );
    fn test_field___imp_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<std_runtime_error>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__imp_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(std_runtime_error),
                "::",
                stringify!(__imp_)
            )
        );
    }
    test_field___imp_();
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorC1ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(
        ::std::mem::size_of::<std_domain_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_domain_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_domain_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_domain_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(
        ::std::mem::size_of::<std_invalid_argument>(),
        16usize,
        concat!("Size of: ", stringify!(std_invalid_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<std_invalid_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(std_invalid_argument))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(
        ::std::mem::size_of::<std_length_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_length_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_length_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_length_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<std_out_of_range>(),
        16usize,
        concat!("Size of: ", stringify!(std_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<std_out_of_range>(),
        8usize,
        concat!("Alignment of ", stringify!(std_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(
        ::std::mem::size_of::<std_range_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_range_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_range_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_range_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_overflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_overflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_overflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_overflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_underflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_underflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_underflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_underflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_variant_access {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_variant_access() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_variant_access>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_variant_access))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_variant_access>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_variant_access))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt18bad_variant_access4whatEv"]
    pub fn std_bad_variant_access_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___mbstate8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__mbstate8)
            )
        );
    }
    test_field___mbstate8();
    fn test_field__mbstateL() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(_mbstateL)
            )
        );
    }
    test_field__mbstateL();
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    fn test_field___routine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__routine)
            )
        );
    }
    test_field___routine();
    fn test_field___arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__arg)
            )
        );
    }
    test_field___arg();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___cleanup_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__cleanup_stack)
            )
        );
    }
    test_field___cleanup_stack();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type mbstate_t = __darwin_mbstate_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    fn test_field__base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_base)
            )
        );
    }
    test_field__base();
    fn test_field__size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_size)
            )
        );
    }
    test_field__size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    fn test_field__p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_p)
            )
        );
    }
    test_field__p();
    fn test_field__r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_r)
            )
        );
    }
    test_field__r();
    fn test_field__w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_w)
            )
        );
    }
    test_field__w();
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_file)
            )
        );
    }
    test_field__file();
    fn test_field__bf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_bf)
            )
        );
    }
    test_field__bf();
    fn test_field__lbfsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lbfsize)
            )
        );
    }
    test_field__lbfsize();
    fn test_field__cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_cookie)
            )
        );
    }
    test_field__cookie();
    fn test_field__close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_close)
            )
        );
    }
    test_field__close();
    fn test_field__read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_read)
            )
        );
    }
    test_field__read();
    fn test_field__seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_seek)
            )
        );
    }
    test_field__seek();
    fn test_field__write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_write)
            )
        );
    }
    test_field__write();
    fn test_field__ub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ub)
            )
        );
    }
    test_field__ub();
    fn test_field__extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_extra)
            )
        );
    }
    test_field__extra();
    fn test_field__ur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ur)
            )
        );
    }
    test_field__ur();
    fn test_field__ubuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ubuf)
            )
        );
    }
    test_field__ubuf();
    fn test_field__nbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
            },
            119usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_nbuf)
            )
        );
    }
    test_field__nbuf();
    fn test_field__lb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lb)
            )
        );
    }
    test_field__lb();
    fn test_field__blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_blksize)
            )
        );
    }
    test_field__blksize();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __nitems: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __nitems: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: size_t,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char, arg1: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: size_t,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wint_t = __darwin_wint_t;
pub type wctype_t = __darwin_wctype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    fn test_field___min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__min) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__min)
            )
        );
    }
    test_field___min();
    fn test_field___max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__max) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__max)
            )
        );
    }
    test_field___max();
    fn test_field___map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__map) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__map)
            )
        );
    }
    test_field___map();
    fn test_field___types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__types) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__types)
            )
        );
    }
    test_field___types();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    fn test_field___nranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nranges) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneRange),
                "::",
                stringify!(__nranges)
            )
        );
    }
    test_field___nranges();
    fn test_field___ranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ranges) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneRange),
                "::",
                stringify!(__ranges)
            )
        );
    }
    test_field___ranges();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    fn test_field___name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneCharClass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneCharClass),
                "::",
                stringify!(__name)
            )
        );
    }
    test_field___name();
    fn test_field___mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneCharClass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneCharClass),
                "::",
                stringify!(__mask)
            )
        );
    }
    test_field___mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    fn test_field___magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__magic)
            )
        );
    }
    test_field___magic();
    fn test_field___encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__encoding) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__encoding)
            )
        );
    }
    test_field___encoding();
    fn test_field___sgetrune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sgetrune) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__sgetrune)
            )
        );
    }
    test_field___sgetrune();
    fn test_field___sputrune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sputrune) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__sputrune)
            )
        );
    }
    test_field___sputrune();
    fn test_field___invalid_rune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__invalid_rune) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__invalid_rune)
            )
        );
    }
    test_field___invalid_rune();
    fn test_field___runetype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__runetype) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__runetype)
            )
        );
    }
    test_field___runetype();
    fn test_field___maplower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__maplower) as usize - ptr as usize
            },
            1084usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__maplower)
            )
        );
    }
    test_field___maplower();
    fn test_field___mapupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mapupper) as usize - ptr as usize
            },
            2108usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__mapupper)
            )
        );
    }
    test_field___mapupper();
    fn test_field___runetype_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__runetype_ext) as usize - ptr as usize
            },
            3136usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__runetype_ext)
            )
        );
    }
    test_field___runetype_ext();
    fn test_field___maplower_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__maplower_ext) as usize - ptr as usize
            },
            3152usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__maplower_ext)
            )
        );
    }
    test_field___maplower_ext();
    fn test_field___mapupper_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mapupper_ext) as usize - ptr as usize
            },
            3168usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__mapupper_ext)
            )
        );
    }
    test_field___mapupper_ext();
    fn test_field___variable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__variable) as usize - ptr as usize
            },
            3184usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__variable)
            )
        );
    }
    test_field___variable();
    fn test_field___variable_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__variable_len) as usize - ptr as usize
            },
            3192usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__variable_len)
            )
        );
    }
    test_field___variable_len();
    fn test_field___ncharclasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ncharclasses) as usize - ptr as usize
            },
            3196usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__ncharclasses)
            )
        );
    }
    test_field___ncharclasses();
    fn test_field___charclasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__charclasses) as usize - ptr as usize
            },
            3200usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__charclasses)
            )
        );
    }
    test_field___charclasses();
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn wctype(arg1: *const ::std::os::raw::c_char) -> wctype_t;
}
extern "C" {
    pub fn btowc(arg1: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn fgetwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn fgetws(arg1: *mut u32, arg2: ::std::os::raw::c_int, arg3: *mut FILE) -> *mut u32;
}
extern "C" {
    pub fn fputwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn fputws(arg1: *const u32, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwide(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn mbrlen(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsinit(arg1: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn putwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(arg1: u32) -> wint_t;
}
extern "C" {
    pub fn swprintf(arg1: *mut u32, arg2: size_t, arg3: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(arg1: *const u32, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(arg1: wint_t, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn vfwprintf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        arg1: *mut u32,
        arg2: size_t,
        arg3: *const u32,
        arg4: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(arg1: *const u32, arg2: __darwin_va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcrtomb(arg1: *mut ::std::os::raw::c_char, arg2: u32, arg3: *mut mbstate_t) -> size_t;
}
extern "C" {
    pub fn wcscat(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcschr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcscmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcscspn(arg1: *const u32, arg2: *const u32) -> size_t;
}
extern "C" {
    pub fn wcsftime(arg1: *mut u32, arg2: size_t, arg3: *const u32, arg4: *const tm) -> size_t;
}
extern "C" {
    pub fn wcslen(arg1: *const u32) -> size_t;
}
extern "C" {
    pub fn wcsncat(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wcsncmp(arg1: *const u32, arg2: *const u32, arg3: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wcspbrk(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrchr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: size_t,
        arg4: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsspn(arg1: *const u32, arg2: *const u32) -> size_t;
}
extern "C" {
    pub fn wcsstr(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsxfrm(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn wctob(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstod(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstok(arg1: *mut u32, arg2: *const u32, arg3: *mut *mut u32) -> *mut u32;
}
extern "C" {
    pub fn wcstol(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wmemchr(arg1: *const u32, arg2: u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wmemcmp(arg1: *const u32, arg2: *const u32, arg3: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wmemmove(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wmemset(arg1: *mut u32, arg2: u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wprintf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcswidth(arg1: *const u32, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcwidth(arg1: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        arg1: *const u32,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(arg1: *const u32, arg2: __darwin_va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstof(arg1: *const u32, arg2: *mut *mut u32) -> f32;
}
extern "C" {
    pub fn wcstold(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstoll(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn mbsnrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: size_t,
        arg5: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcpcpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcpncpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wcsdup(arg1: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcscasecmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(arg1: *const u32, arg2: *const u32, n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnlen(arg1: *const u32, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn wcsnrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: size_t,
        arg4: size_t,
        arg5: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn open_wmemstream(__bufp: *mut *mut u32, __sizep: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn fgetwln(arg1: *mut FILE, arg2: *mut size_t) -> *mut u32;
}
extern "C" {
    pub fn wcslcat(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn wcslcpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> size_t;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
    fn test_field___fsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__fsr)
            )
        );
    }
    test_field___fsr();
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
    fn test_field___esr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__esr)
            )
        );
    }
    test_field___esr();
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__fp)
            )
        );
    }
    test_field___fp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___fpscr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__fpscr)
            )
        );
    }
    test_field___fpscr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    fn test_field___pagein_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_pagein_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_pagein_state),
                "::",
                stringify!(__pagein_error)
            )
        );
    }
    test_field___pagein_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    fn test_field___ctrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_cpmu_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_cpmu_state64),
                "::",
                stringify!(__ctrs)
            )
        );
    }
    test_field___ctrs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    fn test_field___es() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__es)
            )
        );
    }
    test_field___es();
    fn test_field___ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__ss)
            )
        );
    }
    test_field___ss();
    fn test_field___fs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__fs)
            )
        );
    }
    test_field___fs();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    fn test_field___es() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__es)
            )
        );
    }
    test_field___es();
    fn test_field___ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__ss)
            )
        );
    }
    test_field___ss();
    fn test_field___ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__ns)
            )
        );
    }
    test_field___ns();
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_size)
            )
        );
    }
    test_field_ss_size();
    fn test_field_ss_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_flags)
            )
        );
    }
    test_field_ss_flags();
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    fn test_field_uc_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_onstack)
            )
        );
    }
    test_field_uc_onstack();
    fn test_field_uc_sigmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_sigmask)
            )
        );
    }
    test_field_uc_sigmask();
    fn test_field_uc_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_stack)
            )
        );
    }
    test_field_uc_stack();
    fn test_field_uc_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_link)
            )
        );
    }
    test_field_uc_link();
    fn test_field_uc_mcsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_mcsize)
            )
        );
    }
    test_field_uc_mcsize();
    fn test_field_uc_mcontext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_mcontext)
            )
        );
    }
    test_field_uc_mcontext();
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    fn test_field_sival_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_int)
            )
        );
    }
    test_field_sival_int();
    fn test_field_sival_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_ptr)
            )
        );
    }
    test_field_sival_ptr();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    fn test_field_sigev_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify)
            )
        );
    }
    test_field_sigev_notify();
    fn test_field_sigev_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_signo)
            )
        );
    }
    test_field_sigev_signo();
    fn test_field_sigev_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_value)
            )
        );
    }
    test_field_sigev_value();
    fn test_field_sigev_notify_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify_function)
            )
        );
    }
    test_field_sigev_notify_function();
    fn test_field_sigev_notify_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify_attributes)
            )
        );
    }
    test_field_sigev_notify_attributes();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    fn test_field_si_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_signo)
            )
        );
    }
    test_field_si_signo();
    fn test_field_si_errno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_errno)
            )
        );
    }
    test_field_si_errno();
    fn test_field_si_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_code)
            )
        );
    }
    test_field_si_code();
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_status)
            )
        );
    }
    test_field_si_status();
    fn test_field_si_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_addr)
            )
        );
    }
    test_field_si_addr();
    fn test_field_si_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_value)
            )
        );
    }
    test_field_si_value();
    fn test_field_si_band() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_band)
            )
        );
    }
    test_field_si_band();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    fn test_field___sa_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction_u>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction_u),
                "::",
                stringify!(__sa_handler)
            )
        );
    }
    test_field___sa_handler();
    fn test_field___sa_sigaction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction_u>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction_u),
                "::",
                stringify!(__sa_sigaction)
            )
        );
    }
    test_field___sa_sigaction();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    fn test_field___sigaction_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(__sigaction_u)
            )
        );
    }
    test_field___sigaction_u();
    fn test_field_sa_tramp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_tramp)
            )
        );
    }
    test_field_sa_tramp();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    fn test_field___sigaction_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(__sigaction_u)
            )
        );
    }
    test_field___sigaction_u();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    fn test_field_sv_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_handler)
            )
        );
    }
    test_field_sv_handler();
    fn test_field_sv_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_mask)
            )
        );
    }
    test_field_sv_mask();
    fn test_field_sv_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_flags)
            )
        );
    }
    test_field_sv_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_onstack)
            )
        );
    }
    test_field_ss_onstack();
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    fn test_field_ru_utime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_utime)
            )
        );
    }
    test_field_ru_utime();
    fn test_field_ru_stime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_stime)
            )
        );
    }
    test_field_ru_stime();
    fn test_field_ru_maxrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_maxrss)
            )
        );
    }
    test_field_ru_maxrss();
    fn test_field_ru_ixrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_ixrss)
            )
        );
    }
    test_field_ru_ixrss();
    fn test_field_ru_idrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_idrss)
            )
        );
    }
    test_field_ru_idrss();
    fn test_field_ru_isrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_isrss)
            )
        );
    }
    test_field_ru_isrss();
    fn test_field_ru_minflt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_minflt)
            )
        );
    }
    test_field_ru_minflt();
    fn test_field_ru_majflt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_majflt)
            )
        );
    }
    test_field_ru_majflt();
    fn test_field_ru_nswap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nswap)
            )
        );
    }
    test_field_ru_nswap();
    fn test_field_ru_inblock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_inblock)
            )
        );
    }
    test_field_ru_inblock();
    fn test_field_ru_oublock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_oublock)
            )
        );
    }
    test_field_ru_oublock();
    fn test_field_ru_msgsnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_msgsnd)
            )
        );
    }
    test_field_ru_msgsnd();
    fn test_field_ru_msgrcv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_msgrcv)
            )
        );
    }
    test_field_ru_msgrcv();
    fn test_field_ru_nsignals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nsignals)
            )
        );
    }
    test_field_ru_nsignals();
    fn test_field_ru_nvcsw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nvcsw)
            )
        );
    }
    test_field_ru_nvcsw();
    fn test_field_ru_nivcsw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nivcsw)
            )
        );
    }
    test_field_ru_nivcsw();
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
    fn test_field_ri_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_flags)
            )
        );
    }
    test_field_ri_flags();
}
pub type rusage_info_current = rusage_info_v5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    fn test_field_rlim_cur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rlimit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_cur)
            )
        );
    }
    test_field_rlim_cur();
    fn test_field_rlim_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rlimit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_max)
            )
        );
    }
    test_field_rlim_max();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    fn test_field_wm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<proc_rlimit_control_wakeupmon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proc_rlimit_control_wakeupmon),
                "::",
                stringify!(wm_flags)
            )
        );
    }
    test_field_wm_flags();
    fn test_field_wm_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<proc_rlimit_control_wakeupmon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(proc_rlimit_control_wakeupmon),
                "::",
                stringify!(wm_rate)
            )
        );
    }
    test_field_wm_rate();
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU16>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU16),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU32),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU64),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    fn test_field_w_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wait),
                "::",
                stringify!(w_status)
            )
        );
    }
    test_field_w_status();
    fn test_field_w_T() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
        );
    }
    test_field_w_T();
    fn test_field_w_S() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
        );
    }
    test_field_w_S();
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut u32, arg2: *const ::std::os::raw::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: size_t)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: size_t,
        __little: *const ::std::os::raw::c_void,
        __little_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    fn test_field_sched_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(sched_priority)
            )
        );
    }
    test_field_sched_priority();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_8 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_8 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_8 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_8 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_8 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_8 = 0;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> size_t;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut size_t) -> ::std::os::raw::c_int;
}
pub type __libcpp_timespec_t = timespec;
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type wctrans_t = __darwin_wctrans_t;
extern "C" {
    pub fn nextwctype(arg1: wint_t, arg2: wctype_t) -> wint_t;
}
extern "C" {
    pub fn towctrans(arg1: wint_t, arg2: wctrans_t) -> wint_t;
}
extern "C" {
    pub fn wctrans(arg1: *const ::std::os::raw::c_char) -> wctrans_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    fn test_field_decimal_point() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(decimal_point)
            )
        );
    }
    test_field_decimal_point();
    fn test_field_thousands_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(thousands_sep)
            )
        );
    }
    test_field_thousands_sep();
    fn test_field_grouping() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(grouping)
            )
        );
    }
    test_field_grouping();
    fn test_field_int_curr_symbol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_curr_symbol)
            )
        );
    }
    test_field_int_curr_symbol();
    fn test_field_currency_symbol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(currency_symbol)
            )
        );
    }
    test_field_currency_symbol();
    fn test_field_mon_decimal_point() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(mon_decimal_point)
            )
        );
    }
    test_field_mon_decimal_point();
    fn test_field_mon_thousands_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(mon_thousands_sep)
            )
        );
    }
    test_field_mon_thousands_sep();
    fn test_field_mon_grouping() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(mon_grouping)
            )
        );
    }
    test_field_mon_grouping();
    fn test_field_positive_sign() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(positive_sign)
            )
        );
    }
    test_field_positive_sign();
    fn test_field_negative_sign() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(negative_sign)
            )
        );
    }
    test_field_negative_sign();
    fn test_field_int_frac_digits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_frac_digits)
            )
        );
    }
    test_field_int_frac_digits();
    fn test_field_frac_digits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize
            },
            81usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(frac_digits)
            )
        );
    }
    test_field_frac_digits();
    fn test_field_p_cs_precedes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize
            },
            82usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(p_cs_precedes)
            )
        );
    }
    test_field_p_cs_precedes();
    fn test_field_p_sep_by_space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize
            },
            83usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(p_sep_by_space)
            )
        );
    }
    test_field_p_sep_by_space();
    fn test_field_n_cs_precedes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(n_cs_precedes)
            )
        );
    }
    test_field_n_cs_precedes();
    fn test_field_n_sep_by_space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize
            },
            85usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(n_sep_by_space)
            )
        );
    }
    test_field_n_sep_by_space();
    fn test_field_p_sign_posn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize
            },
            86usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(p_sign_posn)
            )
        );
    }
    test_field_p_sign_posn();
    fn test_field_n_sign_posn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize
            },
            87usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(n_sign_posn)
            )
        );
    }
    test_field_n_sign_posn();
    fn test_field_int_p_cs_precedes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_p_cs_precedes)
            )
        );
    }
    test_field_int_p_cs_precedes();
    fn test_field_int_n_cs_precedes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize
            },
            89usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_n_cs_precedes)
            )
        );
    }
    test_field_int_n_cs_precedes();
    fn test_field_int_p_sep_by_space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize
            },
            90usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_p_sep_by_space)
            )
        );
    }
    test_field_int_p_sep_by_space();
    fn test_field_int_n_sep_by_space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize
            },
            91usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_n_sep_by_space)
            )
        );
    }
    test_field_int_n_sep_by_space();
    fn test_field_int_p_sign_posn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_p_sign_posn)
            )
        );
    }
    test_field_int_p_sign_posn();
    fn test_field_int_n_sign_posn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lconv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize
            },
            93usize,
            concat!(
                "Offset of field: ",
                stringify!(lconv),
                "::",
                stringify!(int_n_sign_posn)
            )
        );
    }
    test_field_int_n_sign_posn();
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn setlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xlocale {
    _unused: [u8; 0],
}
pub type locale_t = *mut _xlocale;
extern "C" {
    pub fn ___mb_cur_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l(arg1: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static _c_locale: locale_t;
}
extern "C" {
    pub fn duplocale(arg1: locale_t) -> locale_t;
}
extern "C" {
    pub fn freelocale(arg1: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn localeconv_l(arg1: locale_t) -> *mut lconv;
}
extern "C" {
    pub fn newlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> locale_t;
}
extern "C" {
    pub fn querylocale(
        arg1: ::std::os::raw::c_int,
        arg2: locale_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uselocale(arg1: locale_t) -> locale_t;
}
extern "C" {
    pub fn ___runetype_l(arg1: __darwin_ct_rune_t, arg2: locale_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower_l(arg1: __darwin_ct_rune_t, arg2: locale_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper_l(arg1: __darwin_ct_rune_t, arg2: locale_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune_l(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctype_l(arg1: *const ::std::os::raw::c_char, arg2: locale_t) -> wctype_t;
}
extern "C" {
    pub fn fprintf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf_l(
        arg1: locale_t,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf_l(
        arg1: locale_t,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf_l(
        arg1: locale_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: locale_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf_l(
        arg1: locale_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: locale_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf_l(
        arg1: ::std::os::raw::c_int,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf_l(
        arg1: ::std::os::raw::c_int,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf_l(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf_l(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: locale_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof_l(arg1: *const ::std::os::raw::c_char, arg2: locale_t) -> f64;
}
extern "C" {
    pub fn atoi_l(arg1: *const ::std::os::raw::c_char, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol_l(arg1: *const ::std::os::raw::c_char, arg2: locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn mblen_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_l(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc_l(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtod_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtol_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtouq_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstombs_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const u32,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: u32,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasestr_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strftime_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
        arg5: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strptime_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
        arg4: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn btowc_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> wint_t;
}
extern "C" {
    pub fn fgetwc_l(arg1: *mut FILE, arg2: locale_t) -> wint_t;
}
extern "C" {
    pub fn fgetws_l(
        arg1: *mut u32,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
        arg4: locale_t,
    ) -> *mut u32;
}
extern "C" {
    pub fn fputwc_l(arg1: u32, arg2: *mut FILE, arg3: locale_t) -> wint_t;
}
extern "C" {
    pub fn fputws_l(arg1: *const u32, arg2: *mut FILE, arg3: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const u32,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const u32,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getwc_l(arg1: *mut FILE, arg2: locale_t) -> wint_t;
}
extern "C" {
    pub fn getwchar_l(arg1: locale_t) -> wint_t;
}
extern "C" {
    pub fn mbrlen_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *mut mbstate_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrtowc_l(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut mbstate_t,
        arg5: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsinit_l(arg1: *const mbstate_t, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsrtowcs_l(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut mbstate_t,
        arg5: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn putwc_l(arg1: u32, arg2: *mut FILE, arg3: locale_t) -> wint_t;
}
extern "C" {
    pub fn putwchar_l(arg1: u32, arg2: locale_t) -> wint_t;
}
extern "C" {
    pub fn swprintf_l(
        arg1: *mut u32,
        n: size_t,
        arg2: locale_t,
        arg3: *const u32,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf_l(
        arg1: *const u32,
        arg2: locale_t,
        arg3: *const u32,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc_l(arg1: wint_t, arg2: *mut FILE, arg3: locale_t) -> wint_t;
}
extern "C" {
    pub fn vfwprintf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const u32,
        arg4: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf_l(
        arg1: *mut u32,
        n: size_t,
        arg2: locale_t,
        arg3: *const u32,
        arg4: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf_l(
        arg1: locale_t,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcrtomb_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: u32,
        arg3: *mut mbstate_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscoll_l(arg1: *const u32, arg2: *const u32, arg3: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsftime_l(
        arg1: *mut u32,
        arg2: size_t,
        arg3: *const u32,
        arg4: *const tm,
        arg5: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsrtombs_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: size_t,
        arg4: *mut mbstate_t,
        arg5: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstod_l(arg1: *const u32, arg2: *mut *mut u32, arg3: locale_t) -> f64;
}
extern "C" {
    pub fn wcstol_l(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul_l(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcswidth_l(arg1: *const u32, arg2: size_t, arg3: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(arg1: *mut u32, arg2: *const u32, arg3: size_t, arg4: locale_t) -> size_t;
}
extern "C" {
    pub fn wctob_l(arg1: wint_t, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcwidth_l(arg1: u32, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf_l(arg1: locale_t, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf_l(arg1: locale_t, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf_l(
        arg1: *mut FILE,
        arg2: locale_t,
        arg3: *const u32,
        arg4: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf_l(
        arg1: *const u32,
        arg2: locale_t,
        arg3: *const u32,
        arg4: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf_l(
        arg1: locale_t,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstof_l(arg1: *const u32, arg2: *mut *mut u32, arg3: locale_t) -> f32;
}
extern "C" {
    pub fn wcstold_l(arg1: *const u32, arg2: *mut *mut u32, arg3: locale_t) -> f64;
}
extern "C" {
    pub fn wcstoll_l(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull_l(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
        arg4: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn mbsnrtowcs_l(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: size_t,
        arg5: *mut mbstate_t,
        arg6: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscasecmp_l(
        arg1: *const u32,
        arg2: *const u32,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        arg1: *const u32,
        arg2: *const u32,
        n: size_t,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnrtombs_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: size_t,
        arg4: size_t,
        arg5: *mut mbstate_t,
        arg6: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn fgetwln_l(arg1: *mut FILE, arg2: *mut size_t, arg3: locale_t) -> *mut u32;
}
extern "C" {
    pub fn nextwctype_l(arg1: wint_t, arg2: wctype_t, arg3: locale_t) -> wint_t;
}
extern "C" {
    pub fn towctrans_l(arg1: wint_t, arg2: wctrans_t, arg3: locale_t) -> wint_t;
}
extern "C" {
    pub fn wctrans_l(arg1: *const ::std::os::raw::c_char, arg2: locale_t) -> wctrans_t;
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field_fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    test_field_fds_bits();
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __nl_cat_d {
    pub __data: *mut ::std::os::raw::c_void,
    pub __size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___nl_cat_d() {
    assert_eq!(
        ::std::mem::size_of::<__nl_cat_d>(),
        16usize,
        concat!("Size of: ", stringify!(__nl_cat_d))
    );
    assert_eq!(
        ::std::mem::align_of::<__nl_cat_d>(),
        8usize,
        concat!("Alignment of ", stringify!(__nl_cat_d))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__nl_cat_d>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__nl_cat_d),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__nl_cat_d>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__nl_cat_d),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
}
pub type nl_catd = *mut __nl_cat_d;
pub type nl_item = __darwin_nl_item;
extern "C" {
    pub fn catopen(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int) -> nl_catd;
}
extern "C" {
    pub fn catgets(
        arg1: nl_catd,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn catclose(arg1: nl_catd) -> ::std::os::raw::c_int;
}
#[doc = " A point in a source file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yy_position {
    #[doc = " File name to which this position refers."]
    pub filename: *mut yy_position_filename_type,
    #[doc = " Current line number."]
    pub line: yy_position_counter_type,
    #[doc = " Current column number."]
    pub column: yy_position_counter_type,
}
#[doc = " Type for file name."]
pub type yy_position_filename_type = std_string;
#[doc = " Type for line and column numbers."]
pub type yy_position_counter_type = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_yy_position() {
    assert_eq!(
        ::std::mem::size_of::<yy_position>(),
        16usize,
        concat!("Size of: ", stringify!(yy_position))
    );
    assert_eq!(
        ::std::mem::align_of::<yy_position>(),
        8usize,
        concat!("Alignment of ", stringify!(yy_position))
    );
    fn test_field_filename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<yy_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(yy_position),
                "::",
                stringify!(filename)
            )
        );
    }
    test_field_filename();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<yy_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(yy_position),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<yy_position>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(yy_position),
                "::",
                stringify!(column)
            )
        );
    }
    test_field_column();
}
#[doc = " Two points in a source file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yy_location {
    #[doc = " Beginning of the located region."]
    pub begin: yy_position,
    #[doc = " End of the located region."]
    pub end: yy_position,
}
#[doc = " Type for file name."]
pub type yy_location_filename_type = yy_position_filename_type;
#[doc = " Type for line and column numbers."]
pub type yy_location_counter_type = yy_position_counter_type;
#[test]
fn bindgen_test_layout_yy_location() {
    assert_eq!(
        ::std::mem::size_of::<yy_location>(),
        32usize,
        concat!("Size of: ", stringify!(yy_location))
    );
    assert_eq!(
        ::std::mem::align_of::<yy_location>(),
        8usize,
        concat!("Alignment of ", stringify!(yy_location))
    );
    fn test_field_begin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<yy_location>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(yy_location),
                "::",
                stringify!(begin)
            )
        );
    }
    test_field_begin();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<yy_location>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(yy_location),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios>(),
        152usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios>(),
        152usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream>(),
        168usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_iostream>(),
        176usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_iostream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_iostream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_iostream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream>(),
        168usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_std___struct_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_std___struct_double4_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_ptr_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___type_list_open0_signed_char_std___type_list_open1_short_std___type_list_open2_int_std___type_list_open3_long_std___type_list_open4_long_long_std___type_list_open5___int128_t_std___nat_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___type_list>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___type_list)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_list>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___type_list)
        )
    );
}
pub type __int128_t = i128;
#[test]
fn __bindgen_test_layout_std___type_list_open0_unsigned_char_std___type_list_open1_unsigned_short_std___type_list_open2_unsigned_int_std___type_list_open3_unsigned_long_std___type_list_open4_unsigned_long_long_std___type_list_open5___uint128_t_std___nat_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___type_list>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___type_list)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_list>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___type_list)
        )
    );
}
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_nano_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_micro_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_milli_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
pub type rep = ::std::os::raw::c_longlong;
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_system_clock_std_chrono_duration_open1_long_long_std_ratio_open2_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>>(
        ),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_ratio_open1_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
pub type rep = ::std::os::raw::c_longlong;
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_steady_clock_std_chrono_steady_clock_duration_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_steady_clock_duration>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_steady_clock_duration>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_steady_clock_duration>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_steady_clock_duration>)
        )
    );
}
pub type type_ = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_std___cxx_atomic_impl_open0_bool__std___cxx_atomic_base_impl_open1_bool__close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___cxx_atomic_impl<std___cxx_atomic_base_impl>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___cxx_atomic_impl<std___cxx_atomic_base_impl>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___cxx_atomic_impl<std___cxx_atomic_base_impl>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___cxx_atomic_impl<std___cxx_atomic_base_impl>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___cxx_atomic_base_impl_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___cxx_atomic_base_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___cxx_atomic_base_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___cxx_atomic_base_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___cxx_atomic_base_impl)
        )
    );
}
pub type type_ = ::std::os::raw::c_longlong;
pub type type_ = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_void_std___builtin_new_allocator___builtin_new_deleter_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
pub type char_type = ::std::os::raw::c_char;
pub type char_type = u32;
pub type char_type = char16_t;
pub type char_type = char32_t;
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_lock_open0_std_mutex_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_unique_lock<std_mutex>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_lock<std_mutex>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_lock<std_mutex>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_lock<std_mutex>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_lock_open0_std_mutex_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_unique_lock<std_mutex>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_lock<std_mutex>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_lock<std_mutex>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_lock<std_mutex>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_system_clock_std_chrono_nanoseconds_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_nanoseconds>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_nanoseconds>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_nanoseconds>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_nanoseconds>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        32usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        32usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_30() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_31() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_32() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
